---
layout: title
title: 设计模式的分类
date: 2019-08-23 14:05:05
categories: 设计模式
tags: Learning PHP设计模式
---
思考并回答以下问题：
* 设计模式分为哪三类？为什么这么分？各举几个例子。

<!--more-->

本章涵盖：
* 创建型设计模式
* 结构型设计模式
* 行为型设计模式

# <span style="color:#339AFF;">创建型设计模式</span>

<span style="color:red">创建型设计模式强调的是实例化过程。</span>设计这些模式的目的是隐藏实例的创建过程，并封装对象使用的知识。5个创建型设计模式包括：
* 单例（Singleton）
* 工厂方法（Factory Method）
* 抽象工厂（Abstract Factory）
* 建造者（Builder）
* 原型（Prototype）

工厂方法模式是这5个设计模式中唯一的一种类设计模式。原型模式属于对象类模式，可以使用PHP \_clone()方法实现。首先基于原型实例化（创建）一个对象，然后由这个实例化对象进一步克隆其他对象。你会发现这种模式很容易使用，相当方便。

使用创建型模式时，最有意思的是，程序和系统越来越依赖于对象组合而不是依赖于类继承时，创建型模式就会很重要——确切地说是至关重要。程序变成由对象构成的系统，而对象又由其他对象组合而成，所以任何单个对象的创建都不应该依赖于创建者。换句话说，对象不应与创建对象的过程紧密绑定。这样一来，就不会由于请求对象的特定特性而影响对象组合。此类设计模式会告诉你如何以最优的方式实现创建过程。图1概要描述了创建型模式如何工作。

> 图1：创建型模式结构
{% asset_img 1.png %}

# <span style="color:#339AFF;">结构型设计模式</span>

<span style="color:red">结构型设计模式研究的是如何组合对象和类来构成更大的结构。</span>在类结构型设计中，要通过多个接口来创建新结构。一个类可能继承多个父类来创建一个新的结构。更常见的是对象结构结合不同的对象来形成新的结构。下面7种模式称为结构型模式。
* 适配器模式（Adapter）（类和对象）
* 桥接模式（Bridge）
* 组合模式（Composite）
* 装饰器模式（Decorator）
* 外观模式（Pacade）
* 享元模式（Flyweight）
* 代理模式（Proxy）

如果需要通过适配（使用多重继承或组合）来结合两个不兼容的系统，适配器就非常重要。但有一个棘手的问题需要处理：PHP不支持多重继承，不过可以看到，PHP提供了一种变通方法来实现类适配器模式。另外，组合不仅适用于对象适配器模式，也适用于装饰器模式。图2提供了结构型设计模式的一个可视化表示。

> 图2：结构型模式强调由现有结构创建新结构
{% asset_img 2.png %}

结构型设计模式的重点是创建新结构而不破坏原有的结构。在这个基础上，结构型模式可以保持并提升松耦合标准以实现重用和灵活改变。

# <span style="color:#339AFF;">行为型设计模式</span>

“四人帮”所提供的设计模式中，行为型设计模式占了绝大部分。这一部分将介绍一个类设计模式（模板方法模式）和一个对象设计模式（状态模式）。有11个行为型模式:
* 职责链模式（Chain of Responsibility）
* 命令模式（Command）
* 解释器模式（Interpreter）（类设计模式）
* 迭代器模式（Iterator）
* 中介者模式（Mediator）
* 备忘录模式（Memento）
* 观察者模式（Observer）
* 状态模式（State）
* 策略模式（Strategy）
* 模板方法模式（Template Method）（类设计模式）
* 访问者模式（Visitor）

<span style="color:red">理解行为型设计模式的关键是通信。</span>对于这些模式，重点不再是构成一个设计模式的对象和类，而应转变为对象和类之间的通信。实际上，最好考虑对象如何相互合作来完成任务，从这个角度来理解行为型设计模式。

> 图3：行为型模式强调模式参与者之间的通信
{% asset_img 3.png %}

要重点考虑构成模式的元素之间的交互，这一点非常重要，有些模式的类图看起来是一样的，如状态模式和策略模式。不过，由于参与者通信的方式不同，另外它们处理职责的方式也不同，所以这些模式实际上有很大不同。
