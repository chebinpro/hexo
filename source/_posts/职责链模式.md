---
layout: title
title: 职责链模式
date: 2019-08-23 16:07:52
categories: 设计模式
tags: Learning PHP设计模式
---
思考并回答以下问题：
* 职责链设计模式的好处是，任何对象都可以向处理请求的对象发送请求，而且处理请求的对象可以改变，从而可以结合更多或不同的对象来处理请求。怎么理解？

<!--more-->

本章涵盖：

# <span style="color:#339AFF;">推卸责任</span>

<span style="color:red">职责链设计模式将请求的发送者与接收者分开，这样可以避免请求者与接收者的耦合。另外，这个模式允许将请求沿着一个链传递到多个不同的对象，使这些对象都有机会处理请求。发送者并不需要知道哪一个对象处理这个请求，而对象也不需要知道是谁发送了这个请求。在这二者之间不存在耦合。</span>

<span style="color:red">职责链设计模式的好处是，任何对象都可以向处理请求的对象发送请求，而且处理请求的对象可以改变，从而可以结合更多或不同的对象来处理请求。</span>所以请求者和请求处理器都可以改变，而不必担心对更大的系统带来破坏。图1显示了这个职责链设计模式的类图。

> 图1：职责链设计模式类图
{% asset_img 1.png %}

注意，Client是这个程序中不可缺少的一部分。实际上，在这个结构中，它要完成很重要的工作，因为Client不仅要启动请求，可能还需要启动具体处理器中实现的后继。为此，一种方法是在Handler接口中建立后继方法，并在具体处理器中实现。当Client发出一个请求时，它可以同时建立这个链，并确定后继的顺序。

看到职责链模式时，有些人可能会认为“这只不过是一个大的switch语句而已”。从某种程度上看似乎如此，不过实际上并不是这样。它确实会检查一个请求，确定它是否与某个case条件匹配。不过， switch语句是固定的，而职责链会由各个具体处理器定义其后继。基于这种组织，可以把任意多个响应存储在一个MySQL数据库表中，这样一来，多个不同的“咨询台”可以使用相同的表以及相同的PHP职责链。由于每个具体处理器都包含一个方法来指定它自己的后继， Client通过具体处理器对象指定后继时也就定义了顺序。

另外，由于Client要启动请求链，它可以在开发人员指定的任何位置开始。假设具体请求处理器4、10、15和30可以作为你希望的新咨询台，就可以指定处理器4作为链中的第一个处理器，然后指定处理器10作为它的后继，再指定15为10的后继，而30作为15的后继。所以，职责链具有switch语句所没有的灵活性。

# <span style="color:#339AFF;">MySQL咨询台中的职责链</span>

职责链的第一个实现是一个咨询台，用户可以从一系列帮助主题中选择一个要询问的主题。不论是作为PHP设计模式，还是使用MySQL作为一个文本数据存储系统，这都是一个简单的实现。基本说来，在这个实现中，用户将从一组单选钮中选择一个查询，发出请求，然后通过一个响应链搜索。找到正确的响应时，对象从一个MySQL表获取响应，并在屏幕上显示。

## <span style="color:#00ACC1;">构建和加载响应表</span>

首先要构建一个表，在其中存储文本响应。这一章中的MySQL连接同样使用第11章中的连接类和接口。为便于查看，这里再次给出这些类和接口。首先来看接口：
```php
<?php
// 文件名： IConnectInfo.php
interface IConnectInfo
{
    const HOST = "localhost";
    const UNAME = "phpWorker";
    const PW = "easyWay";
    const DBNAME = "dpPatt";
    public function doConnect（）;
}
```
当然，你要使用你自己的连接信息。现在来看实现这个接口的连接类：
```php

```
这一章需要的每一个MySQL连接都会使用这个连接接口和类。

响应表只需要一个ID、一个指示链对象的字段，以及一个文本字段（提供咨询台中的“帮助”文本）：
```php

```
这里增加了自动id字段，因为将来有可能对表进行编辑，这算是一种预备措施，不过如果你愿意也可以将其忽略。另外，这里首先删除一个表，然后再创建一个表，这种做法在开发中很常用。这样可以加速这个过程，并确保在继续处理之前先将原来的表删除。完成表的调试之后，可以使用MySQL命令来创建表（去掉之前首先删除表的那些代码）：
```sql
```
要让这个表真正发挥作用，需要在表中填入对应查询的响应，所以需要一个数据输入模块，包括一个PHP类和一个HTML表单。另外还必须更新咨询素材，所以除了数据输入外，还需要一个数据更新模块。先来看HTML：
```html

```
InsertData和UpdateData类获得HTML表单发送的数据，将数据存储在helpdesk表中。

<font size=3>**InsertData.php**</span>

```php

```

<font size=3>**UpdateData.php**</span>

```php

```
对于这个职责链咨询台，要在数据库表中输入或更新数据，这需要一个简单的表单。图2显示了这个数据输入/更新管理工具的外观。

> 图2：输入响应数据
{% asset_img 2.png %}

只有应用管理员才能输入帮助数据，用户无权访问这个数据输入表单。图2中的查询链值（Query Chain Value）是用户搜寻的请求或帮助的一个标识符。这个特定的程序是这样组织的：请求用一个值来标识查询（q1到q（查询数））。在这个例子中，“咨询台”只有5个查询，所以是q1到q5。不过，完全可以有更多的查询。另外，一旦完成这个程序，如果想增加更多查询，可以使用咨询台数据输入模块（Help Desk Data EntryModule）来增加。接下来只需增加更多具体处理器，构成职责链模式。利用更新模块，咨询台就有了一个微型的内容管理系统（content management system， CMS）。

## <span style="color:#00ACC1;">咨询台职责链</span>

一旦输入请求的响应数据，可以使用职责链来提供一个程序，不仅获取信息，还可以对链序列排序。图3显示了这个咨询台应用的类图。

> 图3：咨询台类图
{% asset_img 3.png %}

在职责链的这个实现中，Client使用一个辅助类（Request）首先发起一个请求，将这个请求发送到第一个具体处理器。Client会以所需的方式设置这个链序列。这里有5个具体处理器类（从Q1到05），调用其中第一个具体处理器之后，这个具体处理器负责其余的工作，可能会处理查询，也可能将请求继续传递到下一个处理器类。

<font size=3>**HTML数据输入、客户和请求参与者**</span>

数据输入表单是一个HTML文档，包含5个单选钮，分别对应不同的“帮助”请求。每个单选钮用一个值标识（表示相应的问题），从q1到q5：
```html

```
css样式表提供了一种“公司”风格（当然，你可以建立你喜欢的任何样式）。将这个文件保存为help.css：
```cs

```
这里的想法是提供一种便捷的方法，允许用户选择，另外允许开发人员创建一个请求（将进入一个职责链流）。图4显示了这个用户界面，用户可以在这里选择要咨询的问题。

> 图4：数据输入用户界面
{% asset_img 4.png %}

Client类处理从HTML表单发出的请求。它从一个$POST变量接受请求，将请求保存在一个变量squeryNow中。然后Client实例化链中各个具体响应（处理器）的实例。实例化这些对象变量后，Client再使用setSuccessor()方法为各个具体处理器建立后继。所以，现在就会以序列顺序“加载”这个链：
```php

```
一旦实例化具体处理器，并分别指定了一个后继（但链上最后一个具体处理器除外，它没有后继）， Client就可以做出请求了。为了帮助做出请求，Client使用了一个辅助类Request：
```php

```

<font size=3>**处理器接口和具体处理器**</span>

职责链的接口是一个抽象类。在这个实现中，它包括两个抽象方法，另外还包含多个属性（将由具体处理器使用）：
```php

```
这些具体处理器分别提供了方法来处理请求和设置后继。这个例子中，处理请求方法非常简单.handleRequest()方法传递请求（将请求作为参数）。（由Client首先发起请求，启动这个链--就像是点燃导火索。）如果$handle变量与Client通过Request辅助类传递的$request匹配，就会由这个具体处理器来处理这个查询。否则，它会将请求继续传递给链中的后继：
```php

```
按照这个职责链的设计，用户只可有5个帮助请求，所以链尾的处理器后继为NULL-也就是说， Client没有为它定义后继。这样可以确保所有请求都有相应的处理器，不会有请求无法得到处理。

# <span style="color:#339AFF;">自动职责链和工厂方法</span>

下面这个例子显示了职责链模式如何与工厂方法模式结合使用。这里不再由一个UI（用户界面）做出请求，职责链使用了一个日期函数作为“请求”。由此可以说明职责链的灵活性。接下来，程序中的具体处理器调用一个工厂方法应用，加载所请求的文本和图像。图5显示了这个应用中两个设计模式之间的关系。

> 图5：职责链通过工厂方法模式处理请求

实际中，很多开发人员都可能根据应用的需要组合使用多个设计模式。工厂方法模式就经常与其他模式结合使用，以建立产品请求。

这个应用是针对学生每周要完成的一项加分作业设计的，这些学生们在研究全球饥荒情况。首先有一个地图，其中包括城市、河流、海洋和其他标志性地点，另外还要为页面增加一个照片和一个文本说明。学生们要找出正确的国家，明确饥荒情况、文明情况和性别差异，最后返回答案来得到学分。

## <span style="color:#00ACC1;">职责链和日期驱动请求</span>

链接到这个应用的地址后，会通过一个index.php文件自动启动Client， Client再把当前日期放在一个变量$queryNow中，这个变量将传递到一个Request辅助类。沿着职责链，查询会查找第一个合适的具体处理器作为工厂方法的客户，由它创建和显示图像和文字素材。

> 日期函数为什么改变：时间巴别塔
如果你用PHP创建过需要在世界范围使用的区分日期的应用，可能会注意到，可能要应用一些奇怪的时区规则（也可能不应用） 。使用PHP 5.4时， 日期对象要求你在php.net/manuallenltimezones.php中查找时区码，把它作为一个字符串直接量放在一个变量中来设置默认时区。例如，Client中使用下面的代码设置请求变量：
```php
$tz = 'America/New_York';
date_default_timezone_set（$tz）;
$this->queryNow-getdate();
```
这里设置了美国东海岸的时区。有些国家，比如印度，时间与UTC相差半小时。中国西部的喀什与东部的北京相差一个时区，二者距离约3400 km（2100英里）按这个距离，在美国很可能跨4个时区。要把时区从"Europe/Minsk"设置为"Australia/Tasmania" ，需要查看时区标识符（如果你住在印第安纳州，可能会查找8个时间标识符一"America/Indiana/Knox"-以及"America/ndianaIndianapolis" 和"America/Indianapolis" ） 。该学学地理了。

首先，要建立一个自动启动，下面的“触发器”文件会启动Client，并保存为index.php：
```php

```
除了由一个日期创建请求外，Client还负责建立后继列表：
```php

```
这里相继建立了类D1到D15，它们是对应不同日期的具体处理器。如果第一个处理器（D1）与请求日期不匹配，则会继续查找下一个，直到找到正确的日期。这里的Request类与第一个职责链例子中相同，用作为Client辅助类：
```php

```
处理器参与者同样是一个抽象类，作为一个接口。其中包含同样的方法，不过针对日期请求还增加了一些属性：
```php

```
接下来，实现请求处理的具体处理器包含有日期范围，用来确定这个具体处理器是否适合完成当前任务：
```php

```
通过使用一个布尔变量（$handleNow）和布尔表达式，处理器首先查询shandleNow，如果为true，则指向一个工厂方法，由它加载必要的素材。从这个角度来看，职责链具体处理器（D1到D15）是一个客户，将从工厂方法做出一个请求。图6显示了这两个模式如何协作。

链接点的代码就包含在具体处理器对象（DI到D15）中。请求代码与所有其他客户请求并没有不同：
```php
$this->hungerFactory = new HungerFactory();
echo $this->hungerFactory->feedFactory(new C1());
```
下一节将分析职责链具体处理器调用的工厂方法设计模式的作用。

## <span style="color:#00ACC1;">工厂方法完成任务</span>

工厂方法模式的工作与第5章中的一个例子类似（见图5-6） ，只是稍有区别。请求由具体处理器发出，而不是从"Client"类发出，不过这一点不会带来任何差异。如图6所示，handleRequest()方法相当于一个客户。

<font size=3>**Creator和HungerFactory**</span>

标识客户来源之后，第一步构造Creator抽象类，这要作为工厂方法设计的接口：
```php

```
factoryMethod()函数和feedFactory()方法使用了类型提示，以确保参数包含Product接口。不过，由于feedFactory()函数不是抽象方法，Creator的所有具体实现都会自动包含这个方法。

正如第5章中看到的，一些工厂方法模式实现会为不同的产品使用不同的工厂（具体创建者）。不过，如果产品类似，具体创建者可以处理任意多个不同的具体产品：
```php
<?php
// HungerFactory-php
class HungerFactory extends Creator
{
    private $country;
    protected function factoryMethod(Product $product)
    $this->country=$product
    return($this->country->getProperties());
}
```
factoryMethod()实现包含一个参数，以便接收具体产品实例。在具体处理器中（即工厂的客户），这个参数在职责链中确定，并发送到工厂方法。各具体产品将满足通过职责链发送的原始请求

<font size=3>**产品和不同国家**</span>

最终结果显示了一个web页面，其中包含一个照片、一个地图和一段简短的文字说明。学生们使用这个应用研究全球饥荒情况，必须找出国家名、婴儿死亡率和不同文化程度的性别差异。

Product接口有一个方法getProperties()，HungerFactory使用这个方法得到所请求的产品。具体的产品类（C1到C15）显示了所需的各个部分：
```php

```
集成产品之后，将返回给客户，在这里客户就是职责链中的具体处理器。图7显示了最后得到的产品。

图片和文字部分放在单独的文件夹中。

<font size=3>**辅助类、资源和样式**</span>

具体产品对象使用了外部样式表，另外有单独的文件夹提供文本和图片文件，还有一个辅助类来完成格式化。图8显示了整个应用的总布局。

> 图8：资源

主资源文件夹名为hunger。其中包含文件夹c01到c15，这些文件夹中分别包含3个文件：clue.txt、map.gif和pic.jpg，我们可以改变任何文件的内容，而不用担心破坏程序。不过需要指出一个诀窍，如果图片的大小改变，相应的具体产品大小也必须改变，以与之匹配。

FormatHelper类可以减少创建输出所使用的HTML：
```php

```
最后，需要利用外部样式表（products.css）把最终产品集成在一起，以便清楚地表达信息：
```css

```
对于所有这些部分，合理的组织至关重要，从长期来看，为这个应用增加新素材以及做出修改都极其容易。

# <span style="color:#339AFF;">易于更新</span>

设计模式最重要的特性是：基于设计模式，开发人员可以顺利地做出改变以及增加新素材，而不会让整个应用像一摞纸牌一样坍塌。一般来讲，开发人员很可能为了达到一些短期目标而选择走捷径，以节省编程时间，但是从长远来看，这种做法有一个严重的后果：最后即使只做简单的修改也必须重构整个程序。

上一节介绍的饥荒应用就是一个很好的例子，对于这样一个应用，重用和改变非常重要。由于这个应用是区分日期的，所以每个学期都需要改变，不过这很容易，因为所有日期查询都在D系列处理器（D1到D15）类中完成，这些处理器都作为职责链模式的一部分。同样，具体产品很容易修改，因为只要图片大小保持不变，所要修改的就只有新图像。名字是不变的（例如，clue.txt、map.gin），而且这样一来，开发人员不必操心程序在给定的文件夹中查找什么。如果增加了新素材，对应新增加的每个素材会增加一个新类，另外对于新增的资源还会增加一个新的文件夹。

出于某种原因，开发人员可能决定职责链采用一种不同的顺序。这很容易，只需要改变原客户的后继，其他所有内容都不用改变。不论如何计划，使用设计模式完成修改都会比尽可能缩减代码要容易得多。有些做法尽管短期奏效，但长期来看可能并不合适。
