---
layout: title
title: 装饰器模式1
date: 2019-08-23 15:38:57
categories: 设计模式
tags: Learning PHP设计模式
---
思考并回答以下问题：


<!--more-->

本章涵盖：

# 什么是装饰器模式

作为一种结构型模式，装饰器（Decorator）模式就是对一个已有的结构增加“装饰”。对于适配器模式，为现有结构增加的是一个适配器类，用来处理不兼容的接口。装饰器模式会向现有对象增加对象。装饰器也称为包装器（类似于适配器），Decorator参与者用具体组件包装Component参与者。图1显示了这个类图，不过在详细介绍这个类图之前，需要先考虑几个细节问题。

> 图1：装饰器类图[隐含Client]
{% asset_img 1.png %}

首先，有些设计模式包含一个抽象类，而且该抽象类还继承了另一个抽象类，这种设计模式为数不多，而装饰器模式就是其中之一。从图1可以看到，通过一个环状聚合将Decorator连接到Component参与者。（“四人帮”给出的类图中使用的是直线，与直线相比，这里的环线看起来更像“包装”。）可以称为Decorator装饰器“包装”了Component。

这个设计既要创建要装饰的组件，还要创建装饰器。可以把Component参与者想成是一个要装修的空房间，要配上家具和地毯——家具和地毯就是具体装饰器。还要注意，所有参与者通过Component共享一个公共的接口。

这个图中包含有Client，不过它实际上并不是这个模式的一部分——甚至连隐含包含都不算是。基于这种松耦合，可以直接请求任何具体组件或装饰器。不过，使用装饰器模式时，Cient包含有Component接口的一个引用。

# 何时使用装饰器模式

“四人帮”指出了使用装饰器的一般原则。基本说来，<span style="color:red">如果想为现有对象增加新功能而不想影响其他对象，就可以使用装饰器模式</span>。如果你好不容易为客户创建了一个网站格式，主要组件的工作都很完美，客户请求新功能时，你肯定不希望推翻重来，再重新创建网站。例如，假设你已经构建了客户原先请求的所有组件，之后客户又有了新的需求，希望在网站中包含视频功能。你不用重写原先的组件，只需要“装饰”现有组件，为它们增加视频功能。这样一来，既可以保持原来的功能，还可以增加新功能。

有些项目可能有时需要装饰，而有时不希望装饰，这些项目体现了装饰器设计模式的另一个重要特性。假设你的基本网站开发模型可以满足大多数客户的要求。不过，有些客户还希望有一些特定的功能来满足他们的特殊需求。并不是所有人都希望或需要这些额外的功能。作为开发人员，你希望你创建的网站能满足客户的业务目标，所以需要提供“本地化”（customerization）特性，即针对特定业务提供的特性。利用装饰器模式，不仅能提供核心功能，还可以用客户要求的特有功能“装饰”这些核心功能。

由于Web和互联网日新月异（其范围更是飞速扩张），装饰器模式可能是你的开发工具包中的一个宝贵财富。使用装饰器模式就相当于你可以吃到蛋糕，或者至少可以装饰一些“糖霜”。

# 最简单的装饰器例子

第一个例子先考虑最简单的装饰器模式，这里只包含最基本的参与者，不过完全可以清楚地展示一个PHP应用。这个例子描述了一个web开发企业，企业计划建立一个基本网站，并提供一些增强功能。不过，web开发人员知道，尽管这个基本计划适用于大多数客户，但客户以后很可能还希望进一步提升。

从这个最简单的装饰器例子还可以看出，利用装饰器模式，可以很容易地增加多个具体装饰器。除了这个例子中提供的3个装饰器之外，看看你能不能增加更多的装饰器。实际上这很容易。

另外由于你能选择要增加的装饰器，所以企业不仅能控制功能，还可以控制项目的成本。装饰器模式很容易使用，不仅能选择装饰中增加什么，还能选择哪些不用增加。

## Component接口

Component参与者是一个接口，在这里，它是一个抽象类IComponent。这个抽象类只有一个属性$site，另外有两个抽象方法getSite()和getPrice()。Component参与者为具体组件和Decorator参与者抽象类建立了接口：
```php

```
在PHP中，抽象方法只有一个很简短的签名，所以尽管getSite()和getPrice()会有期望的返回结果，但抽象方法声明中没有提供更多信息来指示应当生成何种类型的返回结果。

## Decorator接口

这个例子中的装饰器接口可能会让你感到惊讶。这是一个抽象类，而且它扩展了另一个抽象类！这个类的作用就是维护组件接口（IComponent）的一个引用，这是通过扩展IComponent完成的：
```php

```
与所有其他抽象类一样，你也可以实现方法和增加属性。不过，在这个最简单的例子中，Decorator类的主要作用就是维护组件接口的一个链接（引用）。

讨论具体组件参与者之前，下面来看这个装饰器模式实现的类图，如图2所示。

> 图2：最简单的装饰器模式实现的类图
{% asset_img 2.png %}

所有这些参与者都有相同的接口。在所有装饰器模式实现中，你会发现，具体组件和装饰器都有相同的接口。它们的实现可能不同，另外除了基本接口的属性和方法外，组件和装饰器可能还会有额外的属性和方法。不过，从第一个例子我们可以得出，所有具体组件和装饰器都有共同的接口。

## 具体组件

这个例子中只有一个具体组件，它生成一个网站名，另外生成一个基本网站报价（$1200）：

```php

```
两个抽象方法都使用直接量赋值来实现（“Basic Site”和1200），不过灵活性并不体现在如何改变设置的值。实际上，要通过增加装饰器值来改变“Basic Site"值。下一小节会介绍这是如何做到的。

## 具体装饰器

这个例子中的具体装饰器与具体组件有相同的接口。实际上，它们是从Decorator抽象类（而不是IComponent类）继承了这个接口。不过，要记住，Decorator所做的就是继承IComponent接口。

**Maintenance**

```php

```
查看这个具体构造函数，你会发现，它看起来与装饰器几乎完全相同。不过，每个具体装饰器在它包装的具体组件价格上还会增加它自己的一个价格。另外两个具体装饰器与Maintenance装饰器也类似。

**Video**

```php

```

**Database**

```php

```
测试这个应用时，可以看到，在基本价格之上还会增加各个装饰器的价格。另外还指定了装饰器名的格式，增加了两个空格，使之缩进。

装饰器实现中最重要的元素之一就是构造函数，要为构造函数提供一个组件类型。由于这里只有一个具体组件，所有装饰器的实例化都会使用这个组件。使用多个组件时，装饰器可以包装应用中的一部分或全部组件，也可以不包装任何组件。

## 客户

Client类并不是这个设计模式的一部分，甚至连隐含包含都不算是，尽管如此，正确使用Client类至关重要。每个装饰器必须在实例化时“包装”组件，这在上一节已经看到。不过，首先必须创建一个要包装的BasicSite类实例：
```php

```
一旦Client实例化BasicSite，会有一个wrapComponent()方法检查这个实例，以确保参数有正确的数据类型（IComponent），然后分别实例化3个装饰器。（在装饰器设计模式的典型用法中，只会包含所选择的装饰器；可以注释掉两个装饰器，看看不同的组合会对总价有什么影响。）

wrapComponent()方法返回组件时（$this->basicSite），组件已经改变，现在已经包含了增加的装饰。由输出可以看到，具体组件实例现在由3个装饰器包装，不过，要记住，这里给出的是最简单的输出：
```php

```
也可以把wrapComponent()方法中的语句写在构造函数中，这样不用wrapComponent()方法Client也可以包装装饰器。不过，我们还是增加了wrapComponent()方法，这样就能把注意力更多地放在模式中的包装过程上。

# 关于包装器

适配器和装饰器模式都有另外一个名字“包装器”（wrapper）。实际上，在一些定义中，就把包装器描述为适配器。如果你还不太明确包装器的定义，可以先停一下，来看看如何编写一般的包装器，另外如何编写PHP包装器。

## 包装器包装基本类型

要了解包装器，最好的办法就是查看如何包装基本类型。下面的代码显示了如何将一个整数包装在一个对象中，以及如何获取这个整数：
```php

```
如果需要将一个基本类型包装在对象中，如PrimitiveWrap，有些语言允许用内置的包装器来包装基本类型，相比之下，PHP中则要困难一些。一些语言（如Java）对于每一个基本类型都有相应的包装器类，所以在这些语言中，无需再构建新的包装器类。

## PHP中的内置包装器

尽管PHP没有为所有基本类型都提供包装器，不过它确实有自己的包装器。例如，在第5章中就用到过一个包装器的例子，即file_get_contents()包装器。它将一个指定资源（如一个文件名，或者一个文件名的URL）绑定到一个流。下面的例子使用一首诗来说明这一点。首先，将这首诗保存为一个文本文件（haha.txt）：
```txt
<strong>真正的粉丝</strong>
<p>
苟利国家生死以，<br/>
岂因祸福避趋之。<br/>
</p>
--林则徐<br/>
```
file_get_contents()包装器打开haha.txt，以便PHP程序输出。下面显示了这个包装器如何工作：
```php

```
这段代码生成以下输出：
```txt

```
文件名（haha.txt）“包装”在内置的file_get_contents()包装器中。

## 设计模式包装器  

在第7章中，你已经看到对象适配器模式中的适配器（Adapter）参与者如何“包装”被适配者（Adaptee）。采用这种做法，就能创建一个与Adaptee兼容的接口。同样，从以上最简单的装饰器模式例子中可以看到，装饰器（Decorator）参与者可以“包装”一个组件对象，这样就能为这个已有的组件增加职责，而无须对它做任何修改。下面的代码展示了Client如何将组件对象（$component）包装在装饰器（Maintenance）中：
```php
$component = new Maintenance（$component）; 
```
类似于“接口”，在计算机编程中用到“包装器”时，不同的上下文中会有不同的用法和含义。一般来讲，在设计模式中使用“包装器”是为了处理接口的不兼容，或者希望表示用来减少不兼容性的策略。

# 包装多个组件的装饰器

尽管以上最简单的装饰器模式例子中只使用了一个具体组件，不过使用多个组件的情况也很常见。例如，图3显示了一个包含多个具体组件的类图。

> 图3：装饰器模式中使用多个具体组件
{% asset_img 3.png %}

Male和Female类表示IComponent抽象类的具体实现。装饰器采用数组方式增加属性。在这一节后面，我们会分别详细介绍这些属性。

## 多个具体组件

对于实现或装饰来说，包含多个具体组件并不成问题。只要这些具体组件与传入装饰器的组件有相同的接口，就可以在具体装饰器中包装任何组件，就像包含一个组件的程序或系统一样。

## 包含多个状态和值的具体装饰器

在图3中，继承IComponent抽象类接口的装饰器实现了一些方法。有几个问题需要说明。首先，装饰器（Decorator）实现了设置装饰状态时所有没有用到的方法。实际上，装饰器可以识别出组件中某些元素在装饰中不会改变（如组件的年龄和名字）。如果组件对应的方法只是在Decorator中实现，就不必在具体装饰器中重新实现这些方法。其次，在图1中可以看到，装饰器类图指示它至少要实现Component的一些接口。方法Operation()没有用斜体显示，这表示这个方法已经实例化。getAge()和setAge($a)方法已经实现，但是没有使用。如果它们未在Decorator中实现，就必须在各个具体装饰器中实现，因为继承的所有抽象方法都必须在子类中实现。

## 开发人员约会服务

为了说明如何实现一个包装多个组件的装饰器，下面给出一个例子，它为软件开发人员建立了一个约会服务。这里有两个组件，分别是Male和Female，可以分别为这两个组件装饰不同的约会关注点。可以用相同或不同的具体装饰采用任意组合来装饰这些组件。

基本说来，每个组件都有一个名字和指定的年龄。我们假设年龄不是装饰。具体装饰会有不同的状态。各个装饰可以增加到具体组件，不仅如此，与第一个例子中一样，每个具体装饰可以有不同的状态。

**组件接口**

组件接口包括3个属性和5个方法。$date属性用来标识这是一个“约会”，而不是普通的日/月/年形式的日期对象。$ageGroup是该组件所属的组，$feature是由某个具体装饰提供的特性：
```php

```
所以的方法都是抽象的，另外所有属性都是保护属性。

**具体组件**

两个具体组件实现为Male和Female，它们分别有一个构造函数，将$date值（ID）设置为“Male”或“Female”。另外获取方法/设置方法设置了年龄和其他可能增加的装饰：
```php

```
基于两个具体组件设置的初始特性，基本描述了男性（male）和女性（female）的特点：
```php

```
可以使用$setFeature()方法为这两个组件增加其他特性作为装饰。可以把$setFeature()看作是一个组件增强器，而不只是一个组件设置方法。

**包含组件方法的装饰器**

装饰器接口扩展了组件接口。不过，如前所述，它还实现了年龄属性的获取方法和设置方法：
```php

```
如果想增加一个else语句来捕获错误，这很容易做到。不过，目前采用了一种“安静失败”的做法，即不会传递对象。

**具体装饰器**

这个例子中的具体装饰器与前面最简单例子中的具体装饰器有很大不同。并不是只有一个状态，这些具体装饰器都包含数组，其中有多个属性值。除了使用一个包含4种不同语言的具体装饰器作为具体装饰，也可以有4个不同的具体装饰，分别表示一种不同的计算机语言。不过，将相同的选择结合到一个数组中可以达到同样的目标，还可以保持松耦合：
```php

```
所有具体装饰器都有相同的格式。首先使用getFeature()为一个输出变量赋值，设置为所选择的元素，然后在这个输出变量后面加上格式化标记和一般的具体组件信息，共同作为输出：
```php

```
通过使用关联数组（即字符串元素作为键的数组），选择装饰属性时会更为容易一些。

对于每一个特性，所有具体装饰器都有类似的数组：
```php

```
客户应当能很容易地访问具体装饰，所以所有获取方法和设置方法都有public可见性。

不过，不同属性（数组）中设置的值为private，这样可以增加组件装饰过程的封装性。

**Client**

最后，Client类请求一个组件和具体装饰。首先通过实例化选择一个具体组件，然后Client设置感兴趣的年龄组。Client将4个年龄组分别设置为字符串“Age Group N”，其中“N”是1-4之间的一个字符串值：
```php

```
实例化这两个具体组件之一之后，Client将它们包装在某个具体装饰器中来完成装饰。整个过程都在wrapComponent()方法中完成。创建各个实例时，setFeature()方法利用参数（由一个关联数组键构成）来完成组件的装饰。客户会生成以下输出：
```txt
Female
Age Group 4
Grrrl programmer features:
	Preferred programming language:PHP
	Current Hardware: Linux
	Favorite food: Veggies
```
可以看到，装饰器就是具体装饰器类中关联数组的元素。

# HTML用户界面

到目前为止，这本书还没有介绍HTML用户界面（UI）。在第5部分中，所有应用都包括一个HTML用户界面。之所以目前还没有增加HTML用户界面，原因在于我们现在重点强调的是不同设计模式的基本原理。PHP并未嵌在一个HTML包装器中，所生成的HTML也只用于一般的格式化。

下面要用HTML UI来显示如何通过Client类（对象）连接到一个PHP设计模式。使用“开发人员约会服务”一节中的例子，可以看到，HTML与PHP之间的通信与其他项目中任何其他HTML->PHP程序中的通信是一样的。在PHP中，唯一有改变的是允许从HTML表单向Client类传递值。模式中的所有其他参与者都保持不变。

首先，来看我们完成的HTML UI，如图4所示。可以看到，页面使用单选钮来提供所有数据输入。

> 图4：装饰器的数据输入

数据输入很简单，只需要提供这个页面的标准HTML/CSS文件。首先，页面使用了以下CSS文件：
```cs

```
这个页面是针对移动设备的垂直布局建立的，不过也可以很好地用在平板电脑或桌面系统上。接下来给出页面的HTML，如以下代码所示。它调用了一个页面（ClientH.php）。类和文件名中的H表示它将接收HTML数据（可能需要为HTML或PHP脚本增加验证代码；如果某一组单选钮均未选择，就会抛出错误！）：
```html

```
基本上，这个页面会把数据传递到一个PHP页面，就像通过PHP从一个HTML页面向一个MySQL数据库发送数据一样。所以，尽管数据发送到一个装饰器设计模式中的Client类，在传递数据方面，与以往向PHP文件传递其他数据并没有不同。

## Client类传递HTML数据

前面已经指出，从HTML向一个PHP Client类发送数据与向一个数据库表发送数据是类似的。查看ClientH类，可以看到它类似于Client类，只不过使用了DeveloperDating.html文件的数据：
```php

```
通过使用$\_POST关联数组，可以把单选钮变量和值传递到PHP变量。性别（gender）和年龄（age）变量通过构造函数传递，而组件变量（$hotDate）和3个装饰器变量（$proLang、$hardware和$food）都声明为私有变量，取代在原来Client类中使用相应直接量。

## 从变量名到对象实例

要实例化一个对象实例，一般做法是为类实例指定一个命名变量。在这本书中，约定所有类名首字母大写，变量类实例名都使用小写，如下：
```php
$someInstance = new Someclass();
```
只要知道类名，这种格式会很合适。不过，如果需要通过一个从HTML页面传递的变量来声明多个组件，类名必须来自这个变量的值。利用PHP，这个过程极其容易，尤其是与使用某个eval函数的方法相比（使用eval函数也可以达到这个目的，不过烦琐得多）。

在第6章已经看到，通过一个变量命名和实例化一个类时，一般过程就是将类名赋至一个变量，然后用这个变量实例化这个类。例如，假设有一个类名为Nature；可以通过一个变量动态地实例化一个类实例：
```php
$quack = "Nature";
$myNature = new $quack();
```
这样一来，$myNature是Nature类的一个实例。在类ClientH中，可以看到$hotDate变量必须实例化Female或Male组件类。用户要选择男性或女性，需要在两个单选钮中做出选择（两个单选钮都命名为gender） 。两个值分别为类名Female和Male，所以，这些值传递到PHP变量$gender时，就会实例化相应的具体组件类。下面这行代码完成实例化：
```php
$this->hotDate = new $gender();
```
需要说明，这个表达式包含new关键字，另外变量$gender后面有开始和结束小括号。

## 增加装饰

你可能希望最好包含一个查询来了解用户喜欢哪一类电影，以此衡量约会双方的契合度。例如，动作片、爱情片、科幻片和音乐片都可能是用户喜欢的电影类型。可以考察一下你对装饰器设计模式的理解程度，自己动手增加一个具体装饰器类，由用户喜欢的电影类型来装饰所选择的具体组件。

这很简单。实际上，可以复制粘贴现有的某个具体组件，把它重命名为Films，然后改变类别选项，使用Client类中的直接量值测试。如果一切正常，再更新HTML UI，加入电影选择，并修改ClientH类向程序传递这个请求。

程序越庞大，OOP编程和结构型设计模式就越有用。这是因为，第3部分中讨论的所有模式都可以用来改变现有结构的功能，而不必重写原来的结构。