---
layout: title
title: 基本设计模式概念
date: 2019-08-23 14:36:54
categories: 设计模式
tags: Learning PHP设计模式
---
思考并回答以下问题：

<!--more-->

本章涵盖：

如果你唯一的工具是一把锤子，你很可能会把一切问题都看成钉子。

# 设计模式基本原则

# 第一个设计模式原则

第一个原则对于PHP来说有些困难;按接口而不是按实现来编程。以最简单的方式来讲，按接口而不是按实现编程是指，要将变量设置为一个抽象类或接口数据类型的实例，而不是一个具体实现的实例。如果按接口编程，可以将设计与实现解耦合，这样有很多好处，例如，可以很容易地将一个复杂的数据库实现替换为一个简单得多的模拟实现，以便于测试。有些语言的变量声明中包含数据类型，在这些语言中，只需要指定接口作为数据类型，而不是变量实例化的具体类。例如，在一个强类型语言中，可以有下面的声明:
Interface LAlpha接口名
Class Al/phaA
实现IAlpha: AlphaA的数据类型为IAlpha
Variable useAlpha
声明类型为IAlpha (例如， IAlpha useAlpha)
useAlpha
实例化新的AlphaA0
但在PHP中，不能声明一个变量的数据类型为抽象父类(抽象类或接口) ，因为如果不实例化一个类实例，就不能声明数据类型。另外，不能实例化一个抽象类的对象。通过使用以下格式实例化一个具体对象，变量可以“得到”一个数据类型:
	SuseAlpha = new AlphaA();
名为$useAlpha的变量是类AlphaA的一个实例，并认为这是它的数据类型。所以$useAlpha的数据类型就是AlphaA，这是一个具体类的具体实现。不过，尽管这个实例的数据类型是一个具体类，实际上，这个具体类的父类也同时可以作为它的数据类型。很有必要再重复强调一下这个概念:
一个对象实例的数据类型不仅是它实例化的对象类型，该对象的父类也将作为它的数据类型。
如果没有强类型机制，怎么做到呢?在PHP中，可以利用代码提示保证按接口编程。
3.2.2代码提示中使用接口数据类型
第2章“类型提示:类似数据类型”一节中给出了一个例子，展示了如何对接口IProduct使用代码提示。有两个不同的类FruitStore和citrusstore，它们都实现了相同的接口。如果一个方法要求有一个代码提示参数IProduct，通过使用代码提示，这两个类都可以作为这个方法的实参。这个代码提示指定实参必须是IProduct数据类型。仔细检查这个代码段，可以了解如何按接口编写操作。图3-3显示了按接口编写PHP操作的第一步:将对象实例化为接口实现的实例(完整的程序参见“类型提示:类似数据类型”一节)。

图3-3:实例化IProduct的具体实现
图3-3所示的实例化与按接口编程的原则正好背道而驰:变量被实例化为具体实现的实例，而不是其共同接口的实例。由于PHP是弱数据类型语言，还有一点你看不出来，实际上接口也会作为具体实现的数据类型。
使用类型提示时，程序员必须提供满足指定类型提示的对象。如果这个类型提示是一个接口，程序就会正常工作，就好像你指定了接口类型一样。图3-4显示了这个过程的细节。
通过查看图3-3和图3-4，可以看到这里最关键的方法是doInterface()，它包含一个类型提示。两个具体实现的具体实例(Fruitstore或citrusstore)都可以作为doInterface()方法的实参，其输出都是可预测的。只要接口的任何其他实现与IProduct接口一致(包括返回数据类型) ，无论程序变得多复杂都没有关系。只要保证接口，你可以任意做出修改和增补，它们不会破坏程序的其他部分。


图3-4:方法类型提示为接DIProduct
3.2.3抽象类及其接口
为了便于解释按接口而不是按实现编程的原则，这里的例子中使用的接口是用关键字interface创建的。不过，在继续学习后面的内容之前，要了解接口这个概念是指方法及其签名，而不是关键字interface，每个类都有一个接口，由其方法签名构成。由于大多数设计模式很少由一个具体类扩展，所以你要了解扩展一个抽象类就类似于实现一个接口。
在下面的例子中，两个简单的实现扩展了一个简单的抽象类。接下来给出一个使用了类型提示的Client类，由此展示可以使用抽象类实现按接口编程。代码中的注释有助于强制返回期望的返回值。
首先，抽象类IAbstract有一个保护属性(svalueNow) ，另外有两个保护的抽象方法(givecost和giveCity) ，还有一个公共函数displayshow (这不是一个抽象方法) :
<?phpabstract class IAbstract{
//对所有实现都可用的属性protected $valueNow
/*所有实现都必须包含以下两个方法: *
1/必须返回十进制值
abstract protected function giveCost();1/必须返回字符串值
abstract protected function giveCity();
//这个具体函数对//所有类实现都可用1/而不覆盖内容
public function displayShow()

利用一个抽象类的两个不同实现，可以看到，这里所说的“按接口编程”实际上是指类的接口，而不是使用关键字interface定义的接口结构。最后， Client类建立了一个包含代码提示的方法，指定这个抽象类作为接口:

对于不同的地区，结果值是不同的，因为两个具体类NorthRegion和WestRegion分别采用了不同方式来实现这个抽象方法。如果使用了一个不正确的数据类型(例如，一个字符串)，你会看到以下错误消息:
Catchable fatal error: Argument 1 passed to Client::showInterface().must be an instance of IAbstract， string given， called in /Library/
所以，就其自身而言，类型提示可以帮助你尽可能遵守第一个设计模式原则，即按接口而不是按实现来编程。
如果想了解这种编程风格的好处，可以增加IAbstract抽象类的SouthRegion和EastRegion实现。记住为giveCost()方法使用一个小数值， 对givecity()则要使用一个字符串值。保持二者的其他接口一致，把它们增加到Client类中。可以看到，只要保持接口一致，完成增补和修改很容易。
3.2.4第二个设计模式原则
有些OOP程序员认为对象重用就等同于继承。一个类可以有大量属性和方法，扩展这个类就可以重用所有那些对象元素，而不用重新编写代码。可以扩展类，再增加必要的新属性和方法，就一切OK了。不过最后对于紧密绑定的对象，一味扩展可能会带来问题。这个问题属于过度继承，这也是第二个原则的前提:应当优先选择对象组合而不是类继承。
那么对象组合与类继承有什么区别呢?这个说法并不是要完全消除继承。实际上，这表示开发程序时如果有机会使用组合，就应当优先使用组合而不是继承。这样一来，子类就不会因为继承到大量不用的属性和方法而变得过度膨胀。
3.2.5使用客户的基本组合
要了解使用继承和组合之间的区别，可以通过一个简单的例子来说明，这里将使用一个父类和一个子类展示继承，另外使用两个单独的类展示组合。在查看代码之前，图3-5显示了使用继承和组合的差别。
使用继承时，客户可以完成一个实例化来实现数学和文本功能。利用组合，客户要用两个不同的实例来访问这两个类的功能。设计模式中的组合通常是指模式中一个参与者内部的组合。
首先来看使用继承的代码。第一个类(父类)是一个简单的类，包含两个方法来完成加法和除法计算:

第二个类用于增加文本功能。一个方法是将数字转换为字符串，另一个方法是建立一个格式化输出。通过扩展，这个类继承了DoMath的所有功能:

输出是一个格式化的计算结果值:
	Your results: 4
这个输出使用了4个不同方法，其中两个是从父类继承的方法。
再来看组合， Client类使用两个不同的类，分别包含两个方法。DoMath类等同于继承例子中的父类，所以首先来分析DoText类:

DoText类看起来与InheritMath类很相似，实际上也确实如此。不过，它没有继承DoMath类。
在这个例子中，通过组合，客户使用了这两个不同的类，结果是一样的。不过，客户必须实例化两个对象而不是一个。除此之外，组合例子中使用的客户与继承例子中使用的客户非常相似:

结果完全相同，不过Client类必须包含多个类。看起来好像继承更胜一筹，不过在较大的程序中，组合可以避免维护多个继承层次上的各个子类，而且还可以避免可能导致的错误。例如，父类的一个改变会逐级向下传递到子类实现，这可能会影响子类使用的某个算法。


3.2.6委托: IS-A和HAS-A的差别
在设计模式领域中，你会看到有些类的构造中使用了其他类。一个类将一个任务传递给另一个类时，这就是委托(delegation) 。正是这一点使组合拥有了强大的能力。
使用继承时，每一个子类是另一个类或多个类的一部分(I5-A关系) ;而采用组合，对象可以使用一个不同的类或一组类完成一系列任务(USE-A关系) ，这并不是说不能使用继承。实际上，大多数设计模式同时包含有继承和组合。不过，要避免使用继承形成一长串子类、孙子类、曾孙子类等，设计模式方法建议使用浅继承，另外尽量使用多个类的功能。这种方法有助于避免紧密绑定，另外倘若一个具体类有子类，修改这个类设计可能导致程序崩溃，而浅继承可以避免这种情况。
3.3设计模式作为备忘录
要确定何时使用委托以及如何使用，应当包含多少继承，以及如何确保0OP编程中的重用时，可以把设计模式看作是一个备忘录。可以迅速查看一般设计，这些设计往往使用类图展示需要在哪里采用继承和组合。通过使用统一建模语言(Unified ModelingLanguage， UML) ，可以逐步了解如何查看一个类图，并很快地找出其中不同的部分[称为参与者(participants) ]。第4章会介绍结合使用UML和PHP设计模式的有关细节。
设计模式的组织
这本书将沿用“四人帮”在《设计模式》一书中的设计模式组织。总的说来，设计模式是按作用和范围来组织的。设计模式的作用可以分为3大类:
创建型结构型行为型

这种分类也反映了一般所认为的模式所要完成的目标。按范围划分可以分为两大类:类
对象
这一节将简要介绍这些类别划分，并解释这样划分对于选择和理解设计模式的好处。
创建型模式
顾名思义，创建型模式就是用来创建对象的模式。更确切地讲，这些模式是对实例化过程的抽象。如果程序越来越依赖组合，就会减少对硬编码实例化的依赖，而更多地依赖于一组灵活的行为，这些行为可以组织到一个更为复杂的集合中。创建型模式提供了一些方法来封装系统使用的具体类的有关知识，还可以隐藏实例创建和组合的相关信息。
结构型模式
这些模式所关心的是组合结构应当保证结构化。结构型类模式(structural classpatterns)采用继承来组合接口或实现。结构型对象模式(structural object patterns)则描述了组合对象来建立新功能的方法。了解结构型模式对于理解和使用相互关联的类(作为设计模式中的参与者)很有帮助。
行为型模式
到目前为止，绝大多数模式都是行为型对象。这些模式的核心是算法和对象之间职责的分配。 Gamma等人指出，这些设计模式描述的不只是对象或类的模式，它们还描述了类和对象之间的通信模式。
类模式
在两类范围中，第一类范围是类(class) 。这些类模式的重点在于类及其子类之间的关系。在GoF的《设计模式》一书介绍的24个设计模式中，类范围中只包括4种模式。这一点并不奇怪，因为类模式中的关系是通过继承建立的，而且GoF更多地强调组合而不是继承。类模式是静态的，因此在编译时已经固定。
对象模式
尽管大多数设计模式都属于对象范围(object scope) ，不过与类范围中的那些模式-样，很多模式也会使用继承。对象设计模式与类模式的区别在于，对象模式强调的是可以在运行时改变的对象，因此这些模式更具动态性。

3.4选择设计模式
学习设计模式时，很重要的一部分是要学习如何选择最合适的模式。要记住，设计模式并不是模板，它们只是一些一般策略，可以用来处理面向对象编程中经常出现的一般问题。这本书会分别介绍按作用划分的3大类别以及按范围划分的两大类别中的一个设计模式。另外，还有3章(第12章到第14章)专门讨论可以利用设计模式结合使用PHP和MysQL的常用方法。最后这3章中讨论的3个模式都属于对象模式，按作用来讲是行为型模式，这也是GoF介绍最多的一类模式。

3.4.1是什么导致了重新设计
选择设计模式时，首先要问的一个问题是: “是什么导致了重新设计? "例如，假设你建立了一个在线咨询台，用户发出请求，然后数据库做出响应。不过，可以想见，咨询请求和咨询响应的类型都会改变。如果你的程序依赖于某些特定的操作，一旦有改变就可能带来问题。所以，不要建立硬编码的操作来满足请求，职责链(Chain ofResponsibility)设计模式可以提供一种更好的方法，它允许沿着一个链传递请求，这样就可以有多个对象都有机会处理这个请求。
这本书会指出不同的设计模式可以解决哪些类型的问题。这些章节和模式将提供一个上下文，不仅帮助你了解设计模式的一般原则，还可以了解特定模式处理的具体问题。
3.4.2什么会变化
选择设计模式时还要考虑一个问题:设计中什么会变化。不是查看重新设计的原因，这种方法是要查看你希望哪些方面可以改变而无需重新设计。可以看到，现在的重点将转换为封装那些变化的概念。表3-1给出了这本书将要介绍的9个设计模式，按模式的作用、范围和可能变化的方面做了划分。

表3-1:设计模式作用、范围和变化作用 范围 模式名创建型 类  工厂方法对象原型结构型 类  适配器*对象适配器*
	装饰器行为型 类  模板方法对象  状态对象  策略对象  职责链对象  观察者
可能变化的方面实例化对象的子类实例化对象的类对象的接口
对象职责而不派生子类
算法中的步骤对象状态算法
可以满足请求的对象依赖于其他对象的对象数;当前可以有多少个依赖对象
注意: *适配器模式有两种配置:一个类适配器模式和一个对象适配器模式。将在第7章分别介绍。

每个模式都有一个一般用法。变化的部分必须在具体的上下文中理解，后面介绍各个模式时，就能更清楚地了解这些变化。
	解决特殊问题:设计模式是标准答案吗?
因为设计模式是编程中反复出现的常见问题的解决方案，有些人会误以为它们就是一些毫无变化的“标准答案” ，要严格按它要求的去编程。这就像是在说， PHP中的循环结构是一种编程约束。类似于设计模式，引入循环就是为了处理反复出现的编程问题;对于循环来说，所处理的就是重复问题。用一个循环处理100次选代肯定要强过编写100行顺序代码。类似地，与每次做出改变时都重写整个程序相比，使用松耦合的设计模式肯定更胜一筹。所以，你会发现循环结构有很多不同的用法和实现，类似地，你也会发现很多不同的设计模式实现。
3.4.3设计模式与框架有什么区别
与框架相比，设计模式是体系结构中更小的元素，也更为抽象。另外，设计模式没有框架那么特定。因此，设计模式更可重用，也比框架更灵活。
框架的优点与模板有些类似:它们更有指示性，可以更清楚地指示所解决问题的结构。为了提供这种易用性，它们不得不放弃了体系结构的灵活性。如果使用框架，构建应用会快得多，但是所构建的应用会受到框架本身的约束。框架可以包含面向对象结构，通常框架是分层的，每一层处理更大设计中的一个方面。框架的一些特性在设计模式中也有体现，不过，设计模式没有框架那么特定和具体，也没有那么庞大。