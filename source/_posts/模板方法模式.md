---
layout: title
title: 模板方法模式
date: 2019-08-23 15:42:02
categories: 设计模式
tags: Learning PHP设计模式
---
思考并回答以下问题：


<!--more-->

本章涵盖：

# 什么是模板方法模式

首先，要区别两个概念，模板方法（Template Method）设计模式中使用了一个类方法templateMethod()，要知道这二者是不同的。templateMethod()是抽象类中的一个具体方法。这个方法的作用是对抽象方法序列排序，具体实现留给具体类来完成。关键在于，模板方法模式定义了操作中算法的“骨架”，而由具体类来实现。

关于模板方法模式，值得高兴的是它相当简短，实现很容易。只需要一个抽象类和一个具体类，如图1所示。

> 图1：模板方法类图
{% asset_img 1.png %}

可以把抽象类中的模板方法操作看做是“基本操作的组织者”。后面提到模板方法设计模式时，我会将首字母大写（Template Method），谈到模板方法操作时，则会用小写（template method operation）。就像考虑婚礼司仪，她要按某种顺序安排仪式中的一系列事件（操作），包括宴会、切蛋糕、第一支舞、发表感言以及仪式中可能的所有事件。婚礼司仪会遵循一个模板，按一种给定的顺序合理地组织事件，不过她会让新娘的家人具体决定希望如何执行这些事件。例如，宴会可能是一个正式宴会，也可以是一个户外的烧烤晚会，舞蹈可能选择华尔兹也可能是街舞（hip-hop），乐队可以是整个乐团，也可以只请一位手风琴师。事件发生的顺序都是一样的，不过它们的实现有所不同。

# 何时使用模板方法

如果已经明确算法中的一些步骤，不过这些步骤可以采用多种不同的方法实现，就可以使用模板方法模式。“四人帮”指出，如果算法中的步骤不变，可以把这些步骤留给子类具体实现。在这种情况下，可以使用这种设计模式来组织抽象类中的基本操作（函数/方法）。然后由子类实现应用所需的这些操作。

还有一种用法稍微复杂一些，可能需要把子类共同的行为放在一个类中，以避免代码重复。“四人帮”援引了Opdyke和Johnson的“重构为一般性”（refactoring togeneralize），以此描述将重复的代码组织到模板方法模式中的过程。如果使用多个类来解决同一个大型问题，可能很快就会出现重复代码。

最后一点，还可以使用模板方法模式控制子类扩展。这里涉及一个“钩子”操作，将在“模板方法设计模式中的钩子”一节中讨论。可以利用“钩子”控制扩展：只在钩子操作所在的某些位置允许扩展。

# 最简单的例子：对图像和图题使用模板方法模式

在PHP编程中，可能经常会遇到一个问题：要建立带图题的图像。这个算法相当简单，无非是显示图像，然后在图像下面显示文本。

由于模板方法设计中只涉及两个参与者，所以这是最容易理解的模式之一，同时也非常有用。抽象类建立templateMethod()（具体的方法），并由具体类实现这个方法。

## 抽象类

抽象类是这里的关键，因为它同时包含具体和抽象方法。模板方法（这里是指方法本身）往往是具体方法，其操作是抽象的。

要加载一个图片，只需要一个操作使用HTML包装器调用图像URL，要得到文本作为图题并把它放在图像下面，这个操作也同样很简单。

两个抽象方法分别是addPix($pix)和addCaption($cap)。这两个操作都包含一个参数，分别表示图像的URL信息和图题字符串。templateMethod()函数中设置了这两个属性，属性可见性为保护（protected），以提供封装：
```php

```
在模板方法函数中增加这两个参数，以便接收实参，再将接收到的实参进一步传递到保护属性。

## 具体类

要使用模板方法的具体类扩展这个抽象类，并实现基本操作addPix()和addCaption()。算法要求提供相应的代码，可以用来显示图像和适当的图题：
```php

```
这里并没有返回一个对象，而是由这两个操作使用echo语句将结果发送到屏幕。这样做是为了尽可能简化这个例子。现在客户可以使用addPix()和addCaption()方法了。

# 客户

“四人帮”讨论这种设计模式时并没有提到客户，不过类似于客户作为其他设计模式中的一部分，在这里客户就相当于UI连接的基础。所以，可能需要模板方法模式的任何上下文中，都可以考虑这样一个简单的Client类：
```php

```
注意，$mo变量实例化了ConcretecClass，但是它调用templateMethod()，这是从父类继承的一个具体操作。父类（AbstractClass）通过templateMethod()调用子类的操作。图2显示了相应的输出。

> 图2：模板方法建立的图片-图题序列
{% asset_img 1.png %}

实际上，客户只需要提供图像URL和图题文本串。

# 好莱坞原则

“反向控制结构”概念另外也称为“好莱坞原则”（the Hollywood Principle）。这个原则是指父类调用子类的操作，而子类不调用父类的操作。（就像试镜之后，导演告诉年轻的演员，“如果你拿到这个角色，我们会通知你。不要打电话来询问；我们会打电话给你的”。正因如此，这种反向控制结构被称为好莱坞原则。）

与好莱坞原则关联最紧密的模式就是模板方法模式，因为它在父类中实现。除了templateMethod()，父类中的其他操作（方法）都是抽象和保护方法。所以，尽管客户实例化一个具体类，但它调用了父类中实现的方法。图3可以帮助你更清楚地理解这种反向控制结构。

> 图3：好莱坞原则
{% asset_img 3.png %}

不过，我们真正想问的是：为什么好莱坞原则对于OOP和设计模式很重要？从某些方面来讲，这个问题和答案的关键在于与顺序和过程编程思维划定界限。在过程编程中，关键问题是控制流（flow of control），在OOP中，关键问题则是对象职责（object responsibility）。由于过程编程的重点在于控制流，一些解释会使用“控制反向”（inversion of control）来解释好莱坞原则。控制反向从过程编程的角度来讲很有意义，不过在OOP中，大多数控制流都会通过对象职责和协作抽取出来。也就是说，并不是考虑控制流，而应考虑哪些对象将处理某些职责，另外对象如何协作来完成任务。

要在OOP上下文中准确地理解好莱坞原则，最简单的方法就是从框架以及框架中可能的改变来考虑[这里我使用“框架”（framework）这个词来表示程序中的小结构，而不是第3章中与设计模式相区别的那些更大的结构]。模板方法定义了框架，子类可以扩展或重新实现算法的可变部分，不过它们不能改变模板方法的控制流。从子类发出“调用”是重新实现父类的方法，这是好莱坞原则不允许的一种“调用”。只有父类可以做出“调用”来建立或改变框架（操作的执行顺序）。

要理解好菜坞原则，更好的办法可能是按幼儿园里老师和学生之间的关系来考虑，也就是幼儿园原则（Kindergarten Principle）。老师建立一些项目，让孩子们按某种顺序完成，比如数数、认时间，背单词。老师设定好顺序，但是孩子们具体如何完成或者如何实现则由孩子们自己决定。不过，孩子们不能改变老师定好的这个顺序。换句话说，孩子在数数练习中间不能说“我现在想背单词”。这个结构是有序的：

1.数数
2.认时间
3.背单词

老师说，“抱歉，Elmo，我们现在要数数。过一会再背单词吧”。对孩子们来说，这个顺序是不可变的。所以只能由老师来掌控，没有其他可能。在这种情况下，控制反向是不合适的：由父类建立顺序，子类按自己特有的方式完成这些操作。直观看来这并不是“反向”。所以，如果讨论好莱坞原则时谈到控制反向，要记住这个“反向”只在过程编程的控制流上下文中才有意义。

# 结合其他设计模式使用模板方法模式

设计模式并不是孤立存在的，它们存在于编码对象的大环境中，其中一些对象可能是其他设计模式。为了说明这一点，下面结合工厂方法模式来实现第一个例子，我们可以得到相同的结果，即显示一个有图题的图片。由于这个例子只使用了一个图像和图题，看起来有点像高射炮打蚊子——大材小用了，不过，关键是要知道这两个设计模式如何合作。如果你理解了模式之间的交互，就能结合使用更多的模式。模板方法模式将建立算法的顺序，以给定的顺序来显示图像和图题，工厂方法模式则具体创建对象。图4给出了相应的文件图，两个不同模式分别用灰边框区分。

> 图4：有关联关系的模板方法和工厂方法文件图
{% asset_img 4.png %}

结合使用这两个模式是因为它们分别承担不同的角色。模板方法模式建立算法的顺序（首先是图像，然后是图题），工厂方法模式则创建图像和图题。看到这个，你可能认为客户不得不做出请求；不过，情况正好相反。

## 客户工作负担减轻

客户的请求会通过模板方法模式做出。模板方法模式负责组织操作，从而能按适当的顺序自动地传递请求：
```php

```
在这里，Client类主要是错误检查和加载必要的类。只有两行代码与请求有关：
```php
$mo = new TmFac();
$mo->templateMethod();
```
连接两个不同的设计模式之后，Client的工作居然会减少，这看起来有些讽刺，不过利用模式很容易做到。模板方法模式将建立算法的顺序，这些算法再调用工厂来创建图像和图题。所以，Client所请求的只是将接收请求的方法。

## 模板方法参与者

与之前最简单的例子相比，创建模板方法模式的两个类稍有改变。在某些方面， TmFac类相当于一个客户，因为它会向工厂方法模式中的工厂发出请求：
```php

```
templateMethod()操作指定TmFac类中方法的顺序，调用templateMethod()后会按指定的顺序来调用工厂。

# 工厂方法参与者

Client类与工厂方法模式之间没有任何通信。最初的请求由模板方法操作传递，不过它们没有留下任何“足迹”（暂且这么说）。工厂方法参与者所响应的是来自TmFac对象的请求：
```php

```
图5与图2几乎完全相同，只是图题的样式不同。从templateMethod()向工厂做出请求后，由工厂实现的产品会生成图题的样式。

> 图5：按照templateMethod()中的步骤生成的图像和图题
{% asset_img 5.png %}

图5的重点是，由于设计模式力求所有参与者（类和相应的对象）松耦合但相互连接，所以程序很灵活，完全可以通过所有类和接口来返回图像和图题。对于一个简单的图像和图题，可能注意不到这个好处。不过，对于更复杂的算法，如果有更多的步骤，模板方法模式可以提供一个可重用的顺序来组织职责集。产品以及产品中的变化都将通过同样的接口来处理。

# 模板方法设计模式中的钩子

有时模板方法函数中可能有一个你不想要的步骤，某些特定情况下你可能不希望执行这个步骤。例如，假设有一个模板方法，可以累加一个订单的总费用，另外加上税和运费，然后显示交易总金额。不过，顾客告诉你，如果买家购买需要送货的商品超过200美元，可以免运费。这里就可以用到模板方法钩子。

在模板方法设计模式中，利用钩子可以将一个方法作为模板方法的一部分，不过不一定会用到这个方法。换句话说，它是方法的一部分，不过它包含一个钩子，可以处理例外情况。子类可以为算法增加一个可选元素，这样一来，尽管仍按模板方法建立的顺序执行，但有可能并不完成模板方法期望的动作。对于上面这种运费可选的情况，钩子就是解决这个问题最理想的工具。

你可能认为，这与好莱坞原则有冲突（子类没有遵循父类设置的顺序），这样想也没错。好莱坞原则要求只有父类能够改变框架。钩子很特殊，因为尽管它实现了模板方法中的方法，但实现的方法有一个“后门”，也就是说，它会处理例外情况。

要了解钩子是如何工作的，来看一个简单的例子。一家公司销售GPS设备和地图，为顾客沿赞比西河徒步旅行提供帮助。它还提供租船业务。公司老板决定，如果买家购买的需要送货的商品超过200美元，可以免收运费。不过，这不包括租船的费用。所以，他需要这样一个程序，可以累加送货商品的费用，确定是否增加运费，然后加上租船的费用，最后显示总金额。图6显示了这个程序的用户界面。

UI HTML代码使用了一个表单，以便数据输入，表单中使用了单选钮和复选框。单选钮和复选框都有一个值，分别表示产品或服务的价格。下面的HTML代码清单中包括一个HTML数组，用来提供地图选择：
```html

```
一旦用户单击“Send order”（发送订单）按钮，PHP Client类就会启动。不过，先来看这里采用的模板方法模式。

## 建立钩子

在模板方法接口中建立钩子方法看起来很有意思，尽管子类可以改变钩子的行为，但仍然要遵循模板方法中定义的顺序：
```php

```
这里有3个抽象方法——addTax()、addShippingHook()和displayCost()，抽象类IHook实现的templateMethod()中确定了它们的顺序。在这里，钩子方法放在中间，实际上模板方法指定的顺序中，钩子可以放在任意位置。模板方法需要两个参数：一个是总花费，另外还需要一个变量用来确定顾客是否免收运费。这些值必须由Client类提供，Client类则从HTML文档接收原始数据。

## 实现钩子

一旦抽象类中建立了这些抽象方法，并指定了它们执行的顺序，子类将实现所有这3个方法：
```php

```
addTax()和displayCost()方法都是标准方法，只有一个实现。不过，addShippingHook()的实现有所不同，其中有一个条件来确定是否增加运费。这就是钩子。

## 客户以及捕获钩子

由于可以使用二进制字符，开发人员通常会忽视布尔变量的重要性。不过，实际上处理布尔变量很简洁，速度也很快，我发现它们对于捕获钩子尤其适合。在所有钩子操作中，必须有人警告控制流：将有不同的情况发生，而不是正常地执行模板方法中指定的那些默认操作。

**用比较操作符设置布尔值**

不必使用条件语句来建立一个布尔状态，使用比较操作符会更容易，也更简洁。客户中包含以下代码行，可以为前面的模板方法例子中的钩子设置布尔值。
```php
$this->special = （$this->buyTotal >= 200）;
```
这会为布尔变量$this->special赋一个状态true或false，Zambezi Trading Post为货运商品超过200美元的所有订单提供了免收运费的特殊优惠。

接下来看Client类，可以看到模板方法设计模式中的请求如何访问钩子。

**Client类**

Client类根据从HTML表单接收的数据做出一个请求。它必须将租船的费用与购买设备的费用区分开，只根据设备购买费用来计算特殊折扣。将special设置为true或false后，再累加总金额，还要加上税费。由于变量$special是一个布尔变量，不会把它增加到总金额。实际上，$special会作为一个参数传递到templateMethod()方法：
```php

```
首先，利用从单选钮传入$gpsNow变量的值来确定设备的总费用，然后通过一个循环将所有传入复选框数组（$mapNow）的值累加起来，如上一节所述，此时已经建立了布尔变量$special；最后，加上通过一个单选钮传入的$boatNow值。设置$special之后，程序将$boatNow值与$buyTotal值相加。现在可以把这两个变量中的值发送到主程序，主程序将在$templateMethod()参数中使用这两个值。

这个例子很简单，用户的数据输入也很容易，最重要的是，只需要重写Client，就可以很容易地重用这个设计。换句话说，这个设计是可改变而且可重用的。这个例子中使用直接量来表示运费和税费，不过，它们同样也可以修改为不同的值取代直接量。完全可以用客户传入的值，甚至可以使用可计算的费用，而不是直接量。

# 短小精悍的模板方法模式

学习设计模式很不容易，并不适合那些心存畏惧的人，不过模板方法模式不仅很简单，还有很多经验可以借鉴。首先，要解释好莱坞原则，采用模板方法模式是最适合的。这个原则中的“调用”概念实际上是指“遵循某个顺序”。父类（抽象类）建立操作，并设置它们的顺序，而子类具体实现这些操作。“不要打电话来询问，我们会打电话给你的”可以改写为：“我们会建立面试、试镜和才艺测试；你要按我们建立的顺序完成这些测试，但是可以采用你喜欢的任何方式。只是不要改变这个顺序！”

模板方法模式还有一个重要的方面，要记住这是一个设计模式，可以与其他设计模式结合使用。你已经看到，它能与工厂方法模式很好地合作，同样地，这个模式还能与抽象工厂模式协作（而且这样更有帮助）。模板方法模式很简短，所以可以作为其他模式的一部分，也可以作为一个辅助类在很多其他模式中使用。

关于模板方法模式，最好的一点是它很容易学习，而且有重要的经验可以借鉴。不错，模板方法模式有很多应用，这也很重要，不过概念和思想才是设计模式中最重要的部分。作为一个很容易掌握和学习的模式，尽管它很短小，但确实很有意义。
