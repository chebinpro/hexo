---
title: MySQL优化表
date: 2018-11-29 22:15:15
tags: MySQL
---
## 优化表

优化表同样可以提升数据库性能,其中包括优化表结构、表的拆分、分区、表的分析与检查等内容。

<!--more-->

### 优化表结构

1)尽量将字段定义为NOT NULL约束。这是由于:在MysQL中,含有空值的列很难进行查询优化,NULL值会使索引、索引的统计信息以及比较运算变得更加复杂。推荐使用0、一个特殊的值或者一个空字符串代替NULL值。

2)考虑使用enum、set等复合数据类型。对于一个只包含有限数目的特定值的字段,可以考虑将其设计为enum、set等复合数据类型。enum,set等复合数据类型的值可以更快地处理,因为它们在内部是以数值表示的。

3)虽然MysQL支持blob类型,可以存储二进制数据,但是设计数据库表时,图片、音频、视频等二进制数据不要使用数据库存储,毕竟处理这些二进制数据并不是数据库的强项

4)数值型(例如整型)字段的比较比字符串的比较效率高很多,这也符合一项优化原则:字段类型尽量使用最小、最简单的数据类型,典型的例子是IP地址的存储。当前还有很多应用使用char(15)存储IP地址,然而使用无符号整数存储IP地址效率会更高, MySQL提供了inet_aton()和inet_ntoa()函数来解决P地址与整数之间的转换。

### 表的拆分

表的拆分是指将某个表按照某个(或些)条件拆分成两个或多个独立表。表的拆分分为垂直拆分与水平拆分。
1.垂直拆分

垂直拆分按照字段(或者列)进行拆分,其实就是把组成一行的多个列分开,放到不同的表中。这些表具有不同的结构,拆分后的表含有更少的列,例如可以将频繁访问的列置于一张表中,不经常访问的列(例如长文本信息)置于另一张表中,然后在这两张表的记录与记录之间创建1:1关系。举例来说,对于一张用户表而言,不仅包含账号、账户名、密码、性别等基本信息,还包括兴趣爱好(不经常使用的信息)、自我介绍(长文本信息)等扩展信息。设计用户表时,可以将用户表拆分成两个表user1表与user2表,其中user1表中包含账号、账户名、密码、性别等基本信息, user2表中包含兴趣爱好、自我介绍等扩展信息。由于user1表中的记录与user2表中的记录存在1 :1关系,此时还需要在user2表中增加user1表的主键字段user1_no作为外键,并将外键设置为唯一性约束。user1表为父表, user2表为子表。
user1 (user1_no, account_name, password, sex)
user2 (user2_no, interest, introduction, user1_no)

使用垂直拆分的优点在于:垂直拆分可以使得列数据变小,一个数据块(Block)就可以存放更多行的记录,对频繁访问的字段执行select语句,硬盘I/O次数也会相应减少。另外,垂直拆分表可以达到最大化利用Cache的目的。

使用垂直拆分的缺点在于:由于拆分出来的两张表的记录与记录之间存在1 :1关系,这种1:1关系需要使用冗余字段进行维护。另外,一旦访问不经常使用的字段,会引起表之间的join连接操作,额外增加了CPU的负担。

2.水平拆分
水平拆分按照记录(或者行)进行拆分,其实就是把一个表分成几个表,这些表具有相同的列,但是存放更少的数据。拆分的原则通常是按照日期时间维度、地区维度或者特殊的业务维度进行表的拆分.

案例1:某个公司销售记录数据量非常大,可以对销售记录按月进行水平拆分,每个月的销售记录拆分成一张独立表,共拆分成12张独立
表。

案例2:某个集团在各个地区都有分公司,该集团的订单数据量非常大,可以按分公司所在的地区进行水平拆分。

案例3:某电信公司的话单按月份、地市水平拆分后,发现数据量依然很大,可以按号码段进行3次水平拆分。

使用水平拆分的优点在于:将维度作为查询条件执行select语句时,如果维度范围很小(例如查询12月份的销售记录) ,可以有效降低需要扫描的数据和索引的数据块数,加快查询速度。

使用水平拆分的缺点在于:水平拆分会给应用增加复杂度,它通常在查询时需要多个表名。查询所有数据需要union操作,有时,这种复杂度会超过它带来的优点。例如,将维度作为查询条件执行select语句时,如果维度范围很大(例如查询1月份到12月份的销售记录) ,此时需要进行11个union操作,硬盘I/O次数也会增加。

### 分区

分区是按照指定的规则,跨文件系统分配单个表的多个部分。对于海量数据库或者OLAP的应用而言,对表进行适当的分区可以提升数据库性能。MySQL主要支持4种模式的分区,分别是range (范围)分区、list (预定义列表)分区、hash (哈希)分区以及key (键值)分区。无论使用哪一种分区模式,它们都是对表进行“水平分区" 。并且,如果表中存在主键或者唯一性约束字段,要求分区字段必须是主键字段或唯一性约束字段的一部分。分区的原则是按照日期时间维度、地区维度或者特殊的业务维度进行分区,这与水平拆分的原则相同,分区与水平拆分的不同之处如表14-1所示。

{% asset_img 3.png %}

* range (范围)分区:
	这种分区模式允许数据库管理员将数据划分不同范围。例如,数据库管理员可以将销售记录表按照销售年度对该表划分分区。
	
* list (预定义列表)分区:
	这种分区模式允许系统通过数据库管理员定义的离散值列表进行分区。例如:数据库管理员建立了一个横跨3个分区的表,分别根据2011年、2012年和2013年所对应的数据进行分区

* hash (哈希)分区:
	这种分区模式允许数据库管理员通过对表的一个或多个列的hash值进行计算,最后通过这个hash码不同数值对应的数据区域进行分区。例如数据库管理员可以建立一个对表主键hash值进行分区的表

* key (键值)分区: 
	hash分区的一种延伸,这里的key由MySQL自动生成。

上述4种模式的分区中, range (范围)分区最为常用。下面以range分区为例讲解MySQL表分区的方法。下面的SQL语句首先创建一个sale销售记录表,然后再向该表添加销售年度分区(注意sale表的存储引擎为MyISAM) 。
create table sale(
	sale_id int not null,
	sale_date datetime,
	money int
)ENGINE = MyISAM CHARACTER SET = utf8 COLLATE = utf8_general_ci;
alter table sale partition by range columns (sale_date) (
	partition p01 values less than ('2019-1-1'),
	partition p02 values less than ('2020-1-1')
);
MyISAM的sale表经过分区后,产生分区定义文件sale.par、分区索引文件(sale#P#p01.MYI与sale#P#p02.MYI)以及分区数据文件(sale#P#p01.MYD与sale#P#p02.MYD)，如下图所示。

{% asset_img 7.png %}

### 说明

如果sale表的存储引擎为InnoDB,则sale表经过分区后,仅仅产生分区定义文件sale.par,如果sale表的存储引擎为InnoDB,并且使用的是独享表空间(ibd)文件,则sale表经过分区后,除了产生分区定义文件sale.par外,还会产生分区独享表空间文件sale#p#p01.ibd与sale#p#p02.ibd。

接着使用下面的SQL语句向sale表插入记录信息。
insert into sale values(1, '2019-1-2', 100);
insert into sale values(1, '2020-1-2', 100);


1526 - Table has no partition for value from column_list

注意:第二条记录插入失败,原因在于插入的值2020-1-2不在sale表的两个分区范围之内。对于此类问题,可以向sale表添加一个maxvalue(无穷大值)分区。这样,第二条记录就可以成功插入p03分区中。

alter table sale add partition(partition p03 values less than maxvalue);

查询2019年的销售记录可以使用下面的SQL语句示。
explain partitions select * from sale where sale_date<='2019-12-31' and sale_date>='2019-1-1';

结果如下：
+----+-------------+-------+------------+------+---------------+------+---------+------+------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+-------------+
|  1 | SIMPLE      | sale  | p02        | ALL  | NULL          | NULL | NULL    | NULL |    2 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+-------------+

通过explain partitions命令可以发现,查询优化器只需要搜索p02分区,查询范围的缩小可以有效提升检素性能。
如果要删除2019年度的数据,只需要删除p02分区即可,可以使用下面的SQL语句。此时对应分区的物理文件也随之删除。
alter table sale drop partition p02;