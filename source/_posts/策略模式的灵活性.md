---
layout: title
title: 策略模式的灵活性
date: 2019-08-23 16:05:49
categories: 设计模式
tags: Learning PHP设计模式
---
思考并回答以下问题：


<!--more-->

本章涵盖：

# 封装算法

结合MySQL使用PHP时，要完成的任务之一是需要编写算法来处理对MySQL应用做出的不同类型的请求。一般的请求包括创建表，或者输入、选择、修改和删除数据。对于这些不同的请求，算法可能很简单，也可能很复杂，这取决于请求以及表的复杂性。

设计模式的主要原则之一是封装变化的内容。对于发送到PHP类的不同类型的请求，分别有不同的算法来处理这些MySQL请求，变化的显然是算法。这些变化可能很小，也可能是显著的变化，不过通过使用策略（Strategy）设计模式，我们可以大大简化这个过程。

一般来讲，使用设计模式时，首先要考虑“什么会导致重新设计”？然后要避免那些导致重新设计的因素。不过，有没有一种方法既能做出改变又无需重新设计呢？通过封装那些变化的内容，程序员应首先确定程序中哪些会变化，然后封装这些特性。这样一来，一个设计需要改变时，可以改变封装的元素，而不会影响系统的其余部分。由于不同的MySQL任务需要不同的算法，可以封装这些算法（任务），所以策略设计模式非常适用。

## 区分策略和状态设计模式

首先来看图1，它是策略设计模式的类图。

图1：策略设计模式类图
{% asset_img 1.png %}

再回到第10章，看看图1，其中模式参与者的组织与图1中非常相似。在两个设计中，Context参与者都与一个接口有一个聚合关系。在状态模式中，接口为State，在策略模式中则是Strategy接口。除此以外，它们看起来是一样的。

要了解二者的差别，需要了解两个Context参与者与Strategy和State接口及其具体实现的关系有什么不同。表1对这些差别做了一个总结。

> 表1：状态和策略设计模式中上下文和变化的差别

| **模式**  | **什么会变化？**  | **上下文**  |
| :-| :- | :- |
| 状态  | 状态  | 维护子类当前状态的一个实例（定义了当前状态）  |
| 策略  | 算法  | 配置为具体策略对象，这是一个封装的算法。  |

在第10章可以看到， Context包含一个变量，保存了当前的具体状态。这个具体状态提供了一些方法，可以从Context变量中记录的当前状态变迁到另一个状态。

不过，策略模式中的Context参与者并没有记录当前使用的策略。它没有理由这么做，这是因为，与不断改变的状态不同，一般来讲，改变的算法并不依赖于当前正在使用的算法。显然，有些情况下，执行一个算法之前可能首先要使用另一个算法，如试图访问一个表中的数据之前，需要先在表中插入数据。不过，这并不妨碍使用算法尝试从一个空表获取数据。但在状态模式中很容易出现这样一种情况：即一个状态只能进入某些状态，而不能转移到另外一些状态。在第10章中的三路灯泡例子中，如果灯泡处于第二个on状态，就不能进入第一个on状态，也不能进入off状态。它只能转移到第3个on状态。（见第10章中的图5）大多数算法都不是这样。

## 请不要加条件语句

状态和策略设计模式有很多共同的特性，其中之一是Context参与者要避免使用条件语句。如果查看第10章中的例子，你会注意到，这些例子都没有条件语句。第10章的“何时使用状态模式？ ”一节中提供了一些伪代码，指出使用条件语句从一个单元格到下一个单元格难度很大。（不过不用担心，要在一组已有的状态中增加新状态，或者要改变已有的状态，这些都很容易！）

设计模式并不是要求永远不要使用条件或case语句，不过在一些模式中（如状态和策略设计模式），使用条件语句可能会导致维护相当困难。如果要改变一个策略（封装的算法），而且需要改变一大堆条件或case语句，那么引入错误的可能性会更大。另外需要说明，使用这两个模式时，客户参与者中引入条件或case语句是可以接受的，因为客户所要做的就是做出请求。另外，在封装的算法中（具体策略），完成某个任务可能需要一个条件或case语句。类似地，在使用mysqli实现数据输出和错误检查时，往往都会有条件语句。利用策略，不再需要条件语句来选择所需的行为。不同的任务由不同的具体策略来处理，因为客户通过上下文请求具体策略，它必须知道有哪些可用的策略。这并不是说客户选择过程中不能使用条件语句，而是说条件语句不是上下文的一部分。

## 算法族

GoF的《设计模式》中，有些元素的介绍不太详细，其中就包括“算法族”（family of algorithms）的概念。开发人员需要定义一个算法族，但GoF并没有指定设计模式上下文中“族”（family）一词的确切含义。不过，在《Head First Design Patterns》一书中，提出了一个很简单但很有用的概念——行为集（a set of behaviors）。任何依赖于一组特定行为的项目都可以转换为一种策略设计模式，将那些行为封装为策略。也就是说，需要某种算法才能实现这些行为。通过将它们封装为具体的策略，就能使用、重用和完成修改。

这一章中的“族”由使用MySQL表通常所需的行为组成。一般需要输入、修改、获取和删除数据。这些涉及数据操作的行为就构成了一个“族” ，每个族成员可以转换为一个策略。实现这些策略需要不同的算法，还要结合使用MySQL命令和PHP mysqli类。把这些操作放在不同的具体类中（所有具体类实现一个公共接口） ，就成为了策略设计模式的一部分。

# 最简单的策略模式

为了查看使用MySQL连接的一般模式，第一个例子中并没有使用表，而是建立了一个一般模式，以便以后加入各个策略中的细节。由于HTML表单不能把选择的参数传递给PHP类或文件，这个例子会使用多个短小的PHP触发器脚本。这些触发器脚本调用客户的不同方法，客户再通过上下文调用所请求的具体策略。

图2显示了这个实现的文件图。对于每个策略，HTML文件中分别包含相应的表单，表单数据通过一个PHP触发器脚本传递到Client中的方法。Client再通过Context进一步将请求传递到一个具体策略。连接辅助类包括一个接口和类，可以用来连接一个MySQL数据库。

有些开发人员在处理MySQL数据库方面有着丰富的经验，对他们来说，图2看起来可能有些“过度设计”。不过，设计模式的目的是为了便于修改和重用对象。每个具体策略会得到封装，因此只要保持所实现的接口不变，对具体策略的任何修改都不会破坏系统。即使从这个最小策略的角度来看，也很容易看出具体策略中的行为是开放的，允许各种不同的实现。

## 客户和触发器脚本

Client类通过Context做出请求，来创建一个具体策略。这里利用了一组方法来完成对不同策略的请求。请求的关键是下面这两行代码：
```php
$context = new Context(new ConcreteStrategy());
$context->algorithm();
```
每个Client方法提供了要实现的具体策略的名，algorithm()是具体策略中实现的一个Context方法。这个过程可以展示多态（polymorphism）是如何工作的。Client通过一个Context实例发出请求，来请求具体方法的算法，所以所有算法请求看起来都很像，都是$context->algorithm()。不过， Client要实例化Context，并提供一个具体策略作为参数。通过实现具体策略的algorithm()方法，这个参数允许Context使用所请求的具体策略。这样一来，通过采用策略模式，算法就可以独立变化，而不影响使用该算法的客户。在下面的例子中，没有使用多个不同的Client类，而是利用多个不同的触发器脚本来使用相同的客户：

为了触发不同具体策略（封装的算法）的方法，HTML会调用以下的一个PHP触发器脚本：
```php

```
HTML文档中的表单分别调用各个不同的PHP触发器。触发器脚本发出的请求传递到客户，客户再针对各个请求使用相应的一个方法。在策略设计模式中，客户通常会创建一个具体对象并传递到上下文。不过，最初的请求是由HTML文档发出：
```html

```
在这个设计中，比较困难的一点是要保护$\_POST数据，为此可以使用mysqli->realescape-string()方法抽取由HTML文档发送的数据值。可以在提交的所有数据中包含-个额外的变量，指示客户将要使用一个具体策略请求方法，这样就能做出选择而无需使用大量触发器脚本。可以在客户中建立MySQL连接，取出数据、关闭连接，然后把请求继续传递到具体策略，在这里打开第二个连接，通过适当的策略处理这个请求。不过，这个例子的重点是设计模式，而不是解决所有安全问题。所以这里分别提供不同的触发器脚本来完成各个请求。

## Context类和Strategy接口

在状态模式设计中，Context类相当于一个“跟踪者”（track keeper），它会跟踪当前的状态。在策略模式设计中， Context则有完全不同的功能，用于将请求与具体策略分离，使策略和请求可以独立地工作。这体现了请求与后果之间的另外一种松绑定。与此同时，它还有利于从Client发出请求。

Context不是一个接口（既不是抽象类也不是接口），不过它与Strategy接口有聚合关系。“四人帮”指定了以下特征：
* 用一个具体策略对象来配置（参见“客户与触发器脚本”一节中Client类如何实例化Context）
* 维护Strategy对象的一个引用
* 可以定义一个接口，允许strategy访问其数据。

在下面的代码清单中，可以看到ConText类的上述特征：
```php

```
对于以上的3个特性，第一，构造函数希望有一个Istrategy实现作为参数。第二，通过-个封装的属性$strategy（可见性为私有）来维护strategy对象的一个引用。$strategy属性从构造函数参数接收strategy对象实例，这将成为一个具体策略实例。第三，algorithm()方法实现了Istrategy的algorithm()方法，实现为通过Client选择的具体策略。由于Context和Istrategy构成一个聚合关系，所以Context具有抽象类或接口的某些特性。实际上，最好通过聚合来理解Context。查看策略接口Istrategy时，可以看到要实现的方法是algorithm()：
```php
<?php
interface IStrategy
{
	public function algorithm();
}
```
各个具体策略可以采用所需的方式实现这个方法。

## 具体策略

构成具体策略的封装算法族提供了所有可能的策略。对于这个最简单的例子，关键是要了解策略设计模式中不同的参与者如何协同工作。在这一节中，你会看到一个完全实现的例子。

5个具体策略包括以下类：
* DataEntry
* DisplayData
* SearchData
* UpdateData
* DeleteData

这些具体策略分别表示结合使用PHP和MySQL的典型算法。

**DataEntry**

第一个策略表示向一个表中输入数据：
```php

```
**DisplayData**

在这个例子中并没有使用$\_POST['data']，因为这个算法只显示字符串"Here's all thedata!"，它作为一个字符串直接量赋给变量$test：
```php

```
**SearchData**

搜索项在$\_POST['data']中，将传递到$test变量：
```php

```
**UpdateData**

“新”数据在$\_PoST['data']中，并传递到$test变量。在实际的实现中，还可能包含字段名：

**DeleteRecord**

最后，会有一个唯一标识符传入$-POST[ 
'data']并存储在stest中，通过使用这个唯一标识符，可以从表中删除一个记录：
```php

```
**连接接口和类**

所有具体策略都实现相同的连接对象（与其他章中一样）。下面的接口包含了实际程序使用的名：
```php

```
通过使用一个连接类和单独的接口，可以更容易地重用和修改。这里只会修改接口中的常量值。

# 增加数据安全性和参数化算法来扩展策略模式

在上一节给出的最简单的例子中，可以看到结合使用MySQL数据库时PHP策略设计模式的所有基本元素。为了构建一个更健壮的例子，下面这个例子会为不同策略增加功能。这里还增加了一个辅助类，来处理数据从HTML客户到MySQL数据库的安全移动。这说明，客户可以使用通过mysqli->real_escapestring($\_POST['data'])函数传递的数据做出安全的请求。Client类可以自己处理安全性，不过这样一来，除了做出请求外，会为Client类增加额外的责任。

## 数据安全性辅助类

通过使用mysqli->real_escape_string($\_POST['data'])函数，在HTML表单和PHP类之间安全地传递数据，需要有一个MySQL连接，不过一旦打开连接并安全地传递了数据，可以再关闭这个连接，释放连接占用的资源。

考虑到会有不同的具体策略，这个辅助类对于保证各个具体策略的数据安全性分别提供了不同的方法。一个方法是向Client传回一个数组，其中包含该请求所需的数据。图3通过图示表示了辅助类与Strategy的关系。

图3：增加一个辅助类处理数据安全性

图3中没有显示策略模式中Context类后面的部分，不过它仍然遵循图1所示的标准类图。另外，前面使用了MySQL辅助类处理数据库请求，SecureData类同样使用这个辅助类来创建MySQL连接。

对于每一个依赖于HTML表单数据的具体策略， SecureData类中分别提供了相应的方法。DisplayA11具体策略请求显示所有数据，所以它不需要由HTML表单传递的特殊数据：
```php

```
除了setEntry()之外，所有方法都生成一个名为dataPack的数组。setEntry()方法会返回这个dataPack数组的当前内容。取决于具体的请求， SecureData类生成将置于数组中的值，这会传回到Client，并通过algorithm()方法作为请求的一部分发送到一个具体策略。

## 为算法方法增加参数

第二个要增加的特性是修改Strategy算法方法。我们将增加一个数组作为函数的一个参数，这样可以增加灵活性，处理更多的内容。每个算法函数调用都包含一个数组，其中包含从HTML表单传递的数据：
```php
<?php
interface IStrategy
{
	const TABLENOW ="survey";
	public function algorithm(Array $dataPack);
}
```
同样，还要为接口增加一个常量TABLENON，由于这个实现中各个具体策略都使用相同的表，而且PHP能够通过接口传递常量，因此可以建立一个松耦合而且可重用的代码。显然，如果不同的具体策略要使用不同的表，就必须在各个具体策略中指定表引用。参数中的类型提示指示要将数组用作为一个实参。

## 调查表

下面的脚本用于创建一个调查表（数据库表） 。策略设计模式中可以使用更大或更小的表，为此只需要调整具体策略中所用数组的大小：
```php

```
这个特定的类用于创建数据库表，仅在开发和调试阶段使用。一旦建立了所要的表，而且希望安装在不同的系统上，可以删除下面这段代码：
```php
$drop = "DROP TABLE IF EXISTS sthis-tableMaster";

if(sthis->hookup->query($drop) = true)
{
	printf("Old table %s has been dropped.<br/>"，$this->tableMaster);
}
```
并将以下代码：
```php
$sql = "CREATE TABLE Sthis-tableMaster （
```
修改为：
```php
$sql= "CREATE TABLE IF NOT EXISTS sthis->tableMaster （
```
这样一来，如果原来的表中已经存储有数据，就不会被CreateTable类删除。本章中所有其他的MySQL连接都会使用同样的UniversalConnect类。

## 数据输入模块

利用SecureData辅助类和修改后的IStrategy接口（可以为algorithm()方法包含一个参数），对于不同的HTML表单请求，Client可以根据相应的方法更容易地做出请求。在继续学习下面的内容之前，先来看看HTML表单中发出的请求。这里使用了两个表单：一个允许用户输入调查数据，另一个用于查看存储在MySQL表中的数据。两个表单都非常简单，是很通用的HTML表单。两个表单使用同一个CSS文件：
```php

```
CSS只是用来稍做区分。

首先，调查表单只有一个简单的文本输入，另外可以利用单选钮做一些选择：
```html

```
图4显示了在一个平板设备上打开的调查表单。

第二个HTML文档提供了一个管理工具，可以用来检查数据库中的表。同样的，这个HTML表单也很简单，通过策略设计模式将数据从其来源（数据库表）放入HTML表单中：
```html

```
这两个用户界面（UI）都使用了移动布局，只有一列，可以调整这个布局以便在支持互联网功能的移动手机上查看。

两个HTML文档中的按钮分别表示不同的表单。每个表单调用一个触发器文件，再实例化Client类，并调用所需的方法来完成所请求的任务。

## 客户请求帮助

Client没有构造函数，不过有多个方法，可以做不同的请求。这些方法与最简单的例子类似，不过在前面讨论的SecureData辅助类（见“数据安全性辅助类”一节）的帮助下，这些方法可以做更多工作。

首先请回顾SecureData类的工作，然后再来分析Client：
```php

```
除了showAll()方法外，Client中的所有方法都会首先实例化SecureData类、然后使用具体方法作为参数来创建一个上下文对象。接下来，SecureData对象调用具体策略的相应方法创建所需的数组。最后Client方法调用Context->algorithm（），并使用SecureData类返回$secure->setEntry（）数组作为参数。数组的内容取决于HTML表单发送的用户输入以及所请求的策略类型。

“四人帮”指出，不论是否使用，所有具体策略类都有一个共同的接口。因此，所有具体策略类都必须实现Strategy接口的方法（Istrategy中的algorithm()方法）。不过，并不是所有具体策略都需要这个算法，当然实现方式也不完全相同。

可以看到，从某种程度上讲，Client类中的showAll()方法就不需要这个算法。这个方法没有使用SecureData类返回的一个数组，而是创建了一个dummy数组，并把它用作为Context->algorithm()的参数。这是为了满足IStrategy接口的需求，接口要求这个方法必须包含一个数组作为参数。

## Context类重要的小改变

与这一章第一部分中最简单的例子相比，Context类几乎没有改动，只是为algorithm()方法增加了一个参数，这是更新后的Istrategy接口提出的要求。由于context类和IStrategy之间有一种聚合关系，Context类必须包含Istrategy的一个引用。类似于前面最简单的例子，同样要用一个具体策略对象创建Context，这一部分未做任何改变。不过，它还包含一个方法，将实例化具体策略的algorithm()方法实现：
```php

```
> 注意：Context类方法的名字也是"algorithm" ，它要求有一个数组参数。两个方法都命名为algorithm，其目的是为了强调上下文和策略参与者之间的聚合关系。如果觉得有些混淆，可以把这个方法重命名为contextAlgorithm，使它与IStrategy的algorithm()方法有所区别。

Context还有另外一个属性$dataPack，反映了通过Context algorithm()方法传递的数组的名字。然后再传递到具体策略的algorithm()方法。

## 具体策略

通过一个数组向具体策略传递数据的根本目的是允许不同的策略对不同的请求做出响应。这样可以为设计提供灵活性，因为利用数组可以传递大量数据。在下面的具体策略类中可以看到，每个策略类都实现了IStrategy algorithm()方法，其中使用了通过方法数组参数传递的数据。

最简单的策略例子中使用了一个UniversalConnect类，这里的所有具体类同样使用了这个类。表名作为一个常量（TABLENOw）存储在IStrategy接口中。

**DataEntry**

在所有具体策略中，DataEntry类使用的数组最大。这是因为它必须插入HTML调查表提交的所有数据：
```php

```
这里只是标准MySQL语句中使用了条件语句。作为这个类的核心，通用算法没有使用任何条件语句。

DisplayAll将为这个类传递一个dummy数组。可以看到，它只是使用一个通用算法从数据库表向屏幕发送数据：
```php

```
表格可以更好地显示数据，不过它可不是最优的实现。实际上，由于我们的重点是实现设计模式，所以这个格式要尽可能简单。图6显示了这个输出。

**SearchData**

搜索算法将从一个指定字段选择一个指定值。字段名和搜索值通过数组作为一个参数传入algorithm（）方法。如果匹配，则会显示匹配的记录，如果没有找到匹配，就不显示任何结果：
```php

```
也可以替换一个更精巧的算法和显示设计，这很容易。如果需要更多数据，可以修改HTML文档中生成的数据，并把它们放在SecureData类中的一个数组中，这很简单，很容易做到，而且不会影响程序的任何其他组件，对于所有设计模式来说，这都是必不可少的一个要素。图7显示了在Designer/Developer字段中搜索"designer"的结果。

图7：输出显示"designer"的所有匹配结果

**UpdateData**

要改变当前字段中的值，这个实现只需要三个要素：字段名、原来的值和新值。这个算法很灵活，与所有其他具体策略一样，可以修改算法来反映具体的需求：
```php

```
这个输出通知用户已经完成了一个修改。

**DeleteRecord**

最后一个具体策略将删除一条记录，为此只需要数组中的一个元素来传递要删除的记录号。由于创建表时采用的是一种自动编号机制，标识号是一个整数：
```php

```
这个类和相应的具体策略很简单，如果想增加一个更健壮的算法，也很容易做到，而不会破坏程序的其余部分。

# 灵活的策略模式

策略模式很灵活，改变算法时可以只改变一个实现，不仅如此，模式本身还可以有多个实现。一方面，这一章展示了一个最简单的策略设计模式，它可以调用不同的算法，这些算法独立于具体策略之外的数据;另一方面，第二个例子使用了参数，可以向具体策略传递安全的数据。

“四人帮”指出，一种做法是由Context通过参数向Strategy操作传递数据。这正是第二个例子采用的做法。这种方法可以得到提交给策略的数据，同时保证Context与Strategy解耦合，但也可能向Strategy传递它不需要的数据。对于这个问题，可以使用一个数组来解决，利用这个数组（这也包括一个空数组），为Strategy传递数据时会有更大的灵活性。

特定的策略模式实现依赖于特定算法的需求以及它具体需要些什么。一些策略模式实现会存储其上下文的一个引用，因此没有必要传递数据。不过，这样一来， Context和Strategy会更紧密地耦合。

还有一个问题需要考虑：即策略模式所生成的对象（具体策略）个数。在这一章的例子中可以看到，它们都构建了大量的对象（类）来处理一个简单MysQL调查（由PHP驱动）的不同请求。还有可能构建更多对象。不过，相对于重用性以及改变模式所带来的好处，这可能不算太大的问题。构建设计模式是为了提高管理一个应用的速度，而不是为了提高执行代码的速度。如果采用了良构的策略模式，开发人员可以很容易地优化和重新优化封装的算法，而不会搞得一团乱麻。所以速度表现在重用和修改时间上，而且额外对象的开销很小。