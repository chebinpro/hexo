---
layout: title
title: 享元模式
date: 2019-09-26 14:27:42
categories: 设计模式
tags: 大话设计模式
---
思考并回答以下问题：

<!--more-->


# 第一版

> 网站类

```cs

```

> 客户端代码

```cs

```

> 结果显示

```txt
网站分类：产品展示
网站分类：产品展示
网站分类：产品展示
网站分类：博客
网站分类：博客
网站分类：博客
```
如果要做三个产品展示，三个博客的网站，就需要六个网站类的实例，而其实它们本质上都是一样的代码，如果网站增多，实例也就随着增多，这对服务器的资源浪费得很严重。

# 享元模式

> 享元模式（flyweight）结构图


> Flyweight类，它是所有具体享元类的超类或接口，通过这个接口，Flyweight可以接受并作用于外部状态。

```cs
abstract class Flyweight
{
    public abstract void Operation(int extrinsicstate);
}
```

> UnsharedConcreteFlyweight是指那些不需要共享的Flyweight子类。因为Flyweight接口共享成为可能，但它并不强制共享。

```cs
class UnsharedConcreteFlyweight : Flyweight
{
    public override void Operation(int extrinsicstate)
    {
        Console.WriteLine("不共享的具体Flyweight:" + extrinsicstate);
    }
}
```

> FlyweightFactory，是一个享元工厂，用来创建并管理Flyweight对象。它主要是用来确保合理地共享Flyweight，当用户请求一个Flyweight时，FlyweightFactory对象提供一个已创建的实例或者创建一个（如果不存在的话）。

```cs
class FlyweightFactory
{
    private Hashtable flyweights = new Hashtable();

    public FlyweightFactory()
    {
        flyweights.Add("X", new ConcreteFlyweight());
        flyweights.Add("Y", new ConcreteFlyweight());
        flyweights.Add("Z", new ConcreteFlyweight());

    }

    public Flyweight GetFlyweight(string key)
    {
        return ((Flyweight)flyweights[key]);
    }
}
```

> 客户端代码

```cs
class Program
{
    static void Main(string[] args)
    {
        int extrinsicstate = 22;

        FlyweightFactory f = new FlyweightFactory();

        Flyweight fx = f.GetFlyweight("X");
        fx.Operation(--extrinsicstate);

        Flyweight fy = f.GetFlyweight("Y");
        fy.Operation(--extrinsicstate);

        Flyweight fz = f.GetFlyweight("Z");
        fz.Operation(--extrinsicstate);

        UnsharedConcreteFlyweight uf = new UnsharedConcreteFlyweight();

        uf.Operation(--extrinsicstate);

        Console.Read();
    }
}
```

> 结果表示

```txt
具体Flyweight:21
具体Flyweight:20
具体Flyweight:19
不共享的具体Flyweight:18
```
FlyweightFactory根据客户需求返回早已生成好的对象，但一定要事先生成对象实例吗？实际上是不一定需要的，完全可以初始化时什么也不做，到需要时，再去判断对象是否为null来决定是否实例化。

为什么要有UnsharedConcreteFlyweight的存在呢？

这是因为尽管我们大部分时间都需要共享对象来降低内存的损耗，但个别时候也有可能不需要共享的，那么此时的UnsharedConcreteFlyweight子类就有存在的必要了，它可以解决那些不需要共享对象的问题。

# 网站共享代码

网站应该有一个抽象类和一个具体网站类才可以，然后通过网站工厂来产生对象。

> 网站抽象类

```cs
abstract class WebSite
{
    public abstract void Use();
}
```

> 具体网站类

```cs

```

> 网站工厂类

```cs

```

> 客户端代码
```cs

```

> 结果显示

```txt
网站分类：产品展示
网站分类：产品展示
网站分类：产品展示
网站分类：博客
网站分类：博客
网站分类：博客
网站分类总数为 2
```
这样写算是基本实现了享元模式的共享对象的目的，也就是说，不管建几个网站，只要是‘产品展示’，都是一样的，只要是‘博客’，也是完全相同的，但这样是有问题的，你给企业建的网站不是一家企业的，它们的数据不会相同，所以至少它们都应该有不同的账号，你怎么办？

实际上这样写没有体现对象间的不同，只体现了它们共享的部分。

# 内部状态与外部状态

在享元对象内部并且不会随环境改变而改变的共享部分，可以称为是享元对象的内部状态，而随环境改变而改变的、不可以共享的状态就是外部状态了。事实上，享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例除了几个参数外基本上都是相同的，有时就能够受大幅度地减少需要实例化的类的数量。如果能把那些参数移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度地减少单个实例的数目。也就是说，享元模式Flyweight执行时所需的状态是有内部的也可能有外部的，内部状态存储于ConcreteFlyweight对象之中，而外部对象则应该考虑由客户端对象存储或计算，当调用Flyweight对象的操作时，将该状态传递给它。

客户的账号就是外部状态，应该由专门的对象来处理。

> 代码结构图


> 用户类，用于网站的客户账号，是“网站”类的外部状态

```cs

```

> 网站抽象类

```cs

```

> 具体网站类

```cs

```

> 网站工厂类

```cs

```

> 客户端代码

```cs

```

> 结果显示 尽管给六个不同用户使用网站，但实际上只有两个网站实例。
```txt
网站分类：产品展示 用户：小菜
网站分类：产品展示 用户：大鸟
网站分类：产品展示 用户：娇娇
网站分类：博客 用户：老顽童
网站分类：博客 用户：桃谷六仙
网站分类：博客 用户：南海鳄神
得到网站分类总数为 2
```

这样就可以协调内部与外部状态了。由于用了享元模式，哪怕你接手了1000个网站的需求，只要要求相同或类似，你的实际开发代码也就是分类的那几种，对于服务器来说，占用的硬盘空间、内存、CPU资源都是非常少的，这确实是很好的一个方式。

# 享元模式应用

如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用；还有就是对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式。

因为用了享元模式，所以有了共享对象，实例总数就大大减少了，如果共享的对象越多，存储节约也就越多，节约量随着共享状态的增多而增大。

实际上在.NET中，字符串string就是运用了Flyweight模式。举个例子吧。Object.ReferenceEquals（object objA，object objB）方法是用来确定objA与objB是否是相同的实例，返回值为bool值。
```cs
string titleA = "大话设计模式";
string titleB = "大话设计模式";
Console.WriteLine（Object.ReferenceEquals（titleA，titleB））;
```
返回值是True，这两个字符串是相同的实例。

如果每次创建字符串对象时，都需要创建一个新的字符串对象的话，内存的开销会很大。所以如果第一次创建了字符串对象titleA，下次再创建相同的字符串titleB时只是把它的引用指向‘大话设计模式’，这样就实现了‘大话设计模式’在内存中的共享。


享元模式更多的时候是一种底层的设计模式，但现实中也是有应用的。比如说休闲游戏开发中，像围棋、五子棋、跳棋等，它们都有大量的棋子对象，你分析一下，它们的内部状态和外部状态各是什么？

围棋和五子棋只有黑白两色、跳棋颜色略多一些，但也是不太变化的，所以颜色应该是棋子的内部状态，而各个棋子之间的差别主要就是位置的不同，所以方位坐标应该是棋子的外部状态。

对的，像围棋，一盘棋理论上有361个空位可以放棋子，那如果用常规的面向对象方式编程，每盘棋都可能有两三百个棋子对象产生，一台服务器就很难支持更多的玩家玩围棋游戏了，毕竟内存空间还是有限的。如果用了享元模式来处理棋子，那么棋子对象可以减少到只有两个实例，结果……你应该明白的。

在某些情况下，对象的数量可能会太多，从而导致了运行时的资源与性能损耗。那么我们如何去避免大量细粒度的对象，同时又不影响客户程序，是一个值得去思考的问题，享元模式，可以运用共享技术有效地支持大量细粒度的对象。不过，你也别高兴得太早，使用享元模式需要维护一个记录了系统已有的所有享元的列表，而这本身需要耗费资源，另外享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。因此，应当在有足够多的对象实例可供共享时才值得使用享元模式。
